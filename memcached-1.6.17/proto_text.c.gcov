        -:    0:Source:proto_text.c
        -:    0:Graph:proto_text.gcno
        -:    0:Data:proto_text.gcda
        -:    0:Runs:382
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:/*
        -:    3: * Functions for handling the text related protocols, original and meta.
        -:    4: */
        -:    5:
        -:    6:#include "memcached.h"
        -:    7:#include "proto_text.h"
        -:    8:// FIXME: only for process_proxy_stats()
        -:    9:// - some better/different structure for stats subcommands
        -:   10:// would remove this abstraction leak.
        -:   11:#include "proto_proxy.h"
        -:   12:#include "authfile.h"
        -:   13:#include "storage.h"
        -:   14:#include "base64.h"
        -:   15:#ifdef TLS
        -:   16:#include "tls.h"
        -:   17:#endif
        -:   18:#include <string.h>
        -:   19:#include <stdlib.h>
        -:   20:
        -:   21:#define META_SPACE(p) { \
        -:   22:    *p = ' '; \
        -:   23:    p++; \
        -:   24:}
        -:   25:
        -:   26:#define META_CHAR(p, c) { \
        -:   27:    *p = ' '; \
        -:   28:    *(p+1) = c; \
        -:   29:    p += 2; \
        -:   30:}
        -:   31:
        -:   32:// NOTE: being a little casual with the write buffer.
        -:   33:// the buffer needs to be sized that the longest possible meta response will
        -:   34:// fit. Here we allow the key to fill up to half the write buffer, in case
        -:   35:// something terrible has gone wrong.
        -:   36:#define META_KEY(p, key, nkey, bin) { \
        -:   37:    META_CHAR(p, 'k'); \
        -:   38:    if (!bin) { \
        -:   39:        memcpy(p, key, nkey); \
        -:   40:        p += nkey; \
        -:   41:    } else { \
        -:   42:        p += base64_encode((unsigned char *) key, nkey, (unsigned char *)p, WRITE_BUFFER_SIZE / 2); \
        -:   43:        *p = ' '; \
        -:   44:        *(p+1) = 'b'; \
        -:   45:        p += 2; \
        -:   46:    } \
        -:   47:}
        -:   48:
        -:   49:typedef struct token_s {
        -:   50:    char *value;
        -:   51:    size_t length;
        -:   52:} token_t;
        -:   53:
       28:   54:static void _finalize_mset(conn *c, enum store_item_type ret) {
       28:   55:    mc_resp *resp = c->resp;
       28:   56:    item *it = c->item;
       28:   57:    conn_set_state(c, conn_new_cmd);
        -:   58:
        -:   59:    // information about the response line has been stashed in wbuf.
       28:   60:    char *p = resp->wbuf + resp->wbytes;
       28:   61:    char *end = p; // end of the stashed data portion.
        -:   62:
       28:   63:    switch (ret) {
       23:   64:    case STORED:
       23:   65:      if (settings.meta_response_old) {
    #####:   66:          memcpy(p, "OK", 2);
        -:   67:      } else {
       23:   68:          memcpy(p, "HD", 2);
        -:   69:      }
        -:   70:      // Only place noreply is used for meta cmds is a nominal response.
       23:   71:      if (c->noreply) {
        2:   72:          resp->skip = true;
        -:   73:      }
        -:   74:      break;
        -:   75:    case EXISTS:
        3:   76:      memcpy(p, "EX", 2);
        -:   77:      break;
        -:   78:    case NOT_FOUND:
    #####:   79:      memcpy(p, "NF", 2);
        -:   80:      break;
        -:   81:    case NOT_STORED:
        2:   82:      memcpy(p, "NS", 2);
        -:   83:      break;
    #####:   84:    default:
    #####:   85:      c->noreply = false;
    #####:   86:      out_string(c, "SERVER_ERROR Unhandled storage type.");
    #####:   87:      return;
        -:   88:    }
       28:   89:    p += 2;
        -:   90:
       32:   91:    for (char *fp = resp->wbuf; fp < end; fp++) {
        4:   92:        switch (*fp) {
    #####:   93:            case 'O':
        -:   94:                // Copy stashed opaque.
    #####:   95:                META_SPACE(p);
    #####:   96:                while (fp < end && *fp != ' ') {
    #####:   97:                    *p = *fp;
    #####:   98:                    p++;
    #####:   99:                    fp++;
        -:  100:                }
        -:  101:                break;
    #####:  102:            case 'k':
        -:  103:                // Encode the key here instead of earlier to minimize copying.
    #####:  104:                META_KEY(p, ITEM_key(it), it->nkey, (it->it_flags & ITEM_KEY_BINARY));
        -:  105:                break;
        2:  106:            case 'c':
        -:  107:                // We don't have the CAS until this point, which is why we
        -:  108:                // generate this line so late.
        2:  109:                META_CHAR(p, 'c');
        2:  110:                p = itoa_u64(c->cas, p);
        2:  111:                break;
        -:  112:            default:
        -:  113:                break;
        -:  114:        }
        -:  115:    }
        -:  116:
       28:  117:    memcpy(p, "\r\n", 2);
       28:  118:    p += 2;
        -:  119:    // we're offset into wbuf, but good convention to track wbytes.
       28:  120:    resp->wbytes = p - resp->wbuf;
       28:  121:    resp_add_iov(resp, end, p - end);
        -:  122:}
        -:  123:
        -:  124:/*
        -:  125: * we get here after reading the value in set/add/replace commands. The command
        -:  126: * has been stored in c->cmd, and the item is ready in c->item.
        -:  127: */
   301552:  128:void complete_nread_ascii(conn *c) {
  301552*:  129:    assert(c != NULL);
        -:  130:
   301552:  131:    item *it = c->item;
   301552:  132:    int comm = c->cmd;
   301552:  133:    enum store_item_type ret;
   301552:  134:    bool is_valid = false;
        -:  135:
   301552:  136:    pthread_mutex_lock(&c->thread->stats.mutex);
   301552:  137:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
   301552:  138:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  139:
   301552:  140:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
   294310:  141:        if (strncmp(ITEM_data(it) + it->nbytes - 2, "\r\n", 2) == 0) {
        -:  142:            is_valid = true;
        -:  143:        }
        -:  144:    } else {
     7242:  145:        char buf[2];
        -:  146:        /* should point to the final item chunk */
     7242:  147:        item_chunk *ch = (item_chunk *) c->ritem;
    7242*:  148:        assert(ch->used != 0);
        -:  149:        /* :( We need to look at the last two bytes. This could span two
        -:  150:         * chunks.
        -:  151:         */
     7242:  152:        if (ch->used > 1) {
     7242:  153:            buf[0] = ch->data[ch->used - 2];
     7242:  154:            buf[1] = ch->data[ch->used - 1];
        -:  155:        } else {
    #####:  156:            assert(ch->prev);
    #####:  157:            assert(ch->used == 1);
    #####:  158:            buf[0] = ch->prev->data[ch->prev->used - 1];
    #####:  159:            buf[1] = ch->data[ch->used - 1];
        -:  160:        }
     7242:  161:        if (strncmp(buf, "\r\n", 2) == 0) {
     7242:  162:            is_valid = true;
        -:  163:        } else {
    #####:  164:            assert(1 == 0);
        -:  165:        }
        -:  166:    }
        -:  167:
    7242*:  168:    if (!is_valid) {
        -:  169:        // metaset mode always returns errors.
    #####:  170:        if (c->mset_res) {
    #####:  171:            c->noreply = false;
        -:  172:        }
    #####:  173:        out_string(c, "CLIENT_ERROR bad data chunk");
        -:  174:    } else {
   301552:  175:      ret = store_item(it, comm, c);
        -:  176:
        -:  177:#ifdef ENABLE_DTRACE
        -:  178:      uint64_t cas = ITEM_get_cas(it);
        -:  179:      switch (c->cmd) {
        -:  180:      case NREAD_ADD:
        -:  181:          MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -:  182:                                (ret == 1) ? it->nbytes : -1, cas);
        -:  183:          break;
        -:  184:      case NREAD_REPLACE:
        -:  185:          MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -:  186:                                    (ret == 1) ? it->nbytes : -1, cas);
        -:  187:          break;
        -:  188:      case NREAD_APPEND:
        -:  189:          MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -:  190:                                   (ret == 1) ? it->nbytes : -1, cas);
        -:  191:          break;
        -:  192:      case NREAD_PREPEND:
        -:  193:          MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -:  194:                                    (ret == 1) ? it->nbytes : -1, cas);
        -:  195:          break;
        -:  196:      case NREAD_SET:
        -:  197:          MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -:  198:                                (ret == 1) ? it->nbytes : -1, cas);
        -:  199:          break;
        -:  200:      case NREAD_CAS:
        -:  201:          MEMCACHED_COMMAND_CAS(c->sfd, ITEM_key(it), it->nkey, it->nbytes,
        -:  202:                                cas);
        -:  203:          break;
        -:  204:      }
        -:  205:#endif
        -:  206:
   301552:  207:      if (c->mset_res) {
       28:  208:          _finalize_mset(c, ret);
        -:  209:      } else {
   301524:  210:          switch (ret) {
   300886:  211:          case STORED:
   300886:  212:              out_string(c, "STORED");
   300886:  213:              break;
        5:  214:          case EXISTS:
        5:  215:              out_string(c, "EXISTS");
        5:  216:              break;
        2:  217:          case NOT_FOUND:
        2:  218:              out_string(c, "NOT_FOUND");
        2:  219:              break;
      631:  220:          case NOT_STORED:
      631:  221:              out_string(c, "NOT_STORED");
      631:  222:              break;
    #####:  223:          default:
    #####:  224:              out_string(c, "SERVER_ERROR Unhandled storage type.");
        -:  225:          }
        -:  226:      }
        -:  227:
        -:  228:    }
        -:  229:
   301552:  230:    c->set_stale = false; /* force flag to be off just in case */
   301552:  231:    c->mset_res = false;
   301552:  232:    item_remove(c->item);       /* release the c->item reference */
   301552:  233:    c->item = 0;
   301552:  234:}
        -:  235:
        -:  236:#define COMMAND_TOKEN 0
        -:  237:#define SUBCOMMAND_TOKEN 1
        -:  238:#define KEY_TOKEN 1
        -:  239:
        -:  240:#define MAX_TOKENS 24
        -:  241:
        -:  242:#define WANT_TOKENS(ntokens, min, max) \
        -:  243:    do { \
        -:  244:        if ((min != -1 && ntokens < min) || (max != -1 && ntokens > max)) { \
        -:  245:            out_string(c, "ERROR"); \
        -:  246:            return; \
        -:  247:        } \
        -:  248:    } while (0)
        -:  249:
        -:  250:#define WANT_TOKENS_OR(ntokens, a, b) \
        -:  251:    do { \
        -:  252:        if (ntokens != a && ntokens != b) { \
        -:  253:            out_string(c, "ERROR"); \
        -:  254:            return; \
        -:  255:        } \
        -:  256:    } while (0)
        -:  257:
        -:  258:#define WANT_TOKENS_MIN(ntokens, min) \
        -:  259:    do { \
        -:  260:        if (ntokens < min) { \
        -:  261:            out_string(c, "ERROR"); \
        -:  262:            return; \
        -:  263:        } \
        -:  264:    } while (0)
        -:  265:
        -:  266:/*
        -:  267: * Tokenize the command string by replacing whitespace with '\0' and update
        -:  268: * the token array tokens with pointer to start of each token and length.
        -:  269: * Returns total number of tokens.  The last valid token is the terminal
        -:  270: * token (value points to the first unprocessed character of the string and
        -:  271: * length zero).
        -:  272: *
        -:  273: * Usage example:
        -:  274: *
        -:  275: *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {
        -:  276: *      for(int ix = 0; tokens[ix].length != 0; ix++) {
        -:  277: *          ...
        -:  278: *      }
        -:  279: *      ncommand = tokens[ix].value - command;
        -:  280: *      command  = tokens[ix].value;
        -:  281: *   }
        -:  282: */
   560310:  283:static size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {
   560310:  284:    char *s, *e;
   560310:  285:    size_t ntokens = 0;
  560310*:  286:    assert(command != NULL && tokens != NULL && max_tokens > 1);
   560310:  287:    size_t len = strlen(command);
   560310:  288:    unsigned int i = 0;
        -:  289:
   560310:  290:    s = e = command;
 28350819:  291:    for (i = 0; i < len; i++) {
 27791354:  292:        if (*e == ' ') {
  1647739:  293:            if (s != e) {
  1647725:  294:                tokens[ntokens].value = s;
  1647725:  295:                tokens[ntokens].length = e - s;
  1647725:  296:                ntokens++;
  1647725:  297:                *e = '\0';
  1647725:  298:                if (ntokens == max_tokens - 1) {
      845:  299:                    e++;
      845:  300:                    s = e; /* so we don't add an extra token */
      845:  301:                    break;
        -:  302:                }
        -:  303:            }
  1646894:  304:            s = e + 1;
        -:  305:        }
 27790509:  306:        e++;
        -:  307:    }
        -:  308:
   560310:  309:    if (s != e) {
   559460:  310:        tokens[ntokens].value = s;
   559460:  311:        tokens[ntokens].length = e - s;
   559460:  312:        ntokens++;
        -:  313:    }
        -:  314:
        -:  315:    /*
        -:  316:     * If we scanned the whole string, the terminal value pointer is null,
        -:  317:     * otherwise it is the first unprocessed character.
        -:  318:     */
   560310:  319:    tokens[ntokens].value =  *e == '\0' ? NULL : e;
   560310:  320:    tokens[ntokens].length = 0;
   560310:  321:    ntokens++;
        -:  322:
   560310:  323:    return ntokens;
        -:  324:}
        -:  325:
        5:  326:int try_read_command_asciiauth(conn *c) {
        5:  327:    token_t tokens[MAX_TOKENS];
        5:  328:    size_t ntokens;
        5:  329:    char *cont = NULL;
        -:  330:
        -:  331:    // TODO: move to another function.
        5:  332:    if (!c->sasl_started) {
        5:  333:        char *el;
        5:  334:        uint32_t size = 0;
        -:  335:
        -:  336:        // impossible for the auth command to be this short.
        5:  337:        if (c->rbytes < 2)
        1:  338:            return 0;
        -:  339:
        5:  340:        el = memchr(c->rcurr, '\n', c->rbytes);
        -:  341:
        -:  342:        // If no newline after 1k, getting junk data, close out.
        5:  343:        if (!el) {
    #####:  344:            if (c->rbytes > 2048) {
    #####:  345:                conn_set_state(c, conn_closing);
    #####:  346:                return 1;
        -:  347:            }
        -:  348:            return 0;
        -:  349:        }
        -:  350:
        -:  351:        // Looking for: "set foo 0 0 N\r\nuser pass\r\n"
        -:  352:        // key, flags, and ttl are ignored. N is used to see if we have the rest.
        -:  353:
        -:  354:        // so tokenize doesn't walk past into the value.
        -:  355:        // it's fine to leave the \r in, as strtoul will stop at it.
        5:  356:        *el = '\0';
        -:  357:
        5:  358:        ntokens = tokenize_command(c->rcurr, tokens, MAX_TOKENS);
        -:  359:        // ensure the buffer is consumed.
        5:  360:        c->rbytes -= (el - c->rcurr) + 1;
        5:  361:        c->rcurr += (el - c->rcurr) + 1;
        -:  362:
        -:  363:        // final token is a NULL ender, so we have one more than expected.
        5:  364:        if (ntokens < 6
        4:  365:                || strcmp(tokens[0].value, "set") != 0
        4:  366:                || !safe_strtoul(tokens[4].value, &size)) {
        1:  367:            if (!c->resp) {
        1:  368:                if (!resp_start(c)) {
    #####:  369:                    conn_set_state(c, conn_closing);
    #####:  370:                    return 1;
        -:  371:                }
        -:  372:            }
        1:  373:            out_string(c, "CLIENT_ERROR unauthenticated");
        1:  374:            return 1;
        -:  375:        }
        -:  376:
        -:  377:        // we don't actually care about the key at all; it can be anything.
        -:  378:        // we do care about the size of the remaining read.
        4:  379:        c->rlbytes = size + 2;
        -:  380:
        4:  381:        c->sasl_started = true; // reuse from binprot sasl, but not sasl :)
        -:  382:    }
        -:  383:
        4:  384:    if (c->rbytes < c->rlbytes) {
        -:  385:        // need more bytes.
        -:  386:        return 0;
        -:  387:    }
        -:  388:
        -:  389:    // Going to respond at this point, so attach a response object.
        4:  390:    if (!c->resp) {
        4:  391:        if (!resp_start(c)) {
    #####:  392:            conn_set_state(c, conn_closing);
    #####:  393:            return 1;
        -:  394:        }
        -:  395:    }
        -:  396:
        4:  397:    cont = c->rcurr;
        -:  398:    // advance buffer. no matter what we're stopping.
        4:  399:    c->rbytes -= c->rlbytes;
        4:  400:    c->rcurr += c->rlbytes;
        4:  401:    c->sasl_started = false;
        -:  402:
        -:  403:    // must end with \r\n
        -:  404:    // NB: I thought ASCII sets also worked with just \n, but according to
        -:  405:    // complete_nread_ascii only \r\n is valid.
        4:  406:    if (strncmp(cont + c->rlbytes - 2, "\r\n", 2) != 0) {
    #####:  407:        out_string(c, "CLIENT_ERROR bad command line termination");
    #####:  408:        return 1;
        -:  409:    }
        -:  410:
        -:  411:    // payload should be "user pass", so we can use the tokenizer.
        4:  412:    cont[c->rlbytes - 2] = '\0';
        4:  413:    ntokens = tokenize_command(cont, tokens, MAX_TOKENS);
        -:  414:
        4:  415:    if (ntokens < 3) {
        1:  416:        out_string(c, "CLIENT_ERROR bad authentication token format");
        1:  417:        return 1;
        -:  418:    }
        -:  419:
        3:  420:    if (authfile_check(tokens[0].value, tokens[1].value) == 1) {
        2:  421:        out_string(c, "STORED");
        2:  422:        c->authenticated = true;
        2:  423:        c->try_read_command = try_read_command_ascii;
        2:  424:        pthread_mutex_lock(&c->thread->stats.mutex);
        2:  425:        c->thread->stats.auth_cmds++;
        2:  426:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  427:    } else {
        1:  428:        out_string(c, "CLIENT_ERROR authentication failure");
        1:  429:        pthread_mutex_lock(&c->thread->stats.mutex);
        1:  430:        c->thread->stats.auth_cmds++;
        1:  431:        c->thread->stats.auth_errors++;
        1:  432:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  433:    }
        -:  434:
        -:  435:    return 1;
        -:  436:}
        -:  437:
   559887:  438:int try_read_command_ascii(conn *c) {
   559887:  439:    char *el, *cont;
        -:  440:
   559887:  441:    if (c->rbytes == 0)
        -:  442:        return 0;
        -:  443:
   559887:  444:    el = memchr(c->rcurr, '\n', c->rbytes);
   559887:  445:    if (!el) {
      429:  446:        if (c->rbytes > 2048) {
        -:  447:            /*
        -:  448:             * We didn't have a '\n' in the first few k. This _has_ to be a
        -:  449:             * large multiget, if not we should just nuke the connection.
        -:  450:             */
        -:  451:            char *ptr = c->rcurr;
     4201:  452:            while (*ptr == ' ') { /* ignore leading whitespaces */
     4196:  453:                ++ptr;
        -:  454:            }
        -:  455:
        5:  456:            if (ptr - c->rcurr > 100 ||
        3:  457:                (strncmp(ptr, "get ", 4) && strncmp(ptr, "gets ", 5))) {
        -:  458:
        2:  459:                conn_set_state(c, conn_closing);
        2:  460:                return 1;
        -:  461:            }
        -:  462:
        -:  463:            // ASCII multigets are unbound, so our fixed size rbuf may not
        -:  464:            // work for this particular workload... For backcompat we'll use a
        -:  465:            // malloc/realloc/free routine just for this.
        3:  466:            if (!c->rbuf_malloced) {
        3:  467:                if (!rbuf_switch_to_malloc(c)) {
    #####:  468:                    conn_set_state(c, conn_closing);
    #####:  469:                    return 1;
        -:  470:                }
        -:  471:            }
        -:  472:        }
        -:  473:
      427:  474:        return 0;
        -:  475:    }
   559458:  476:    cont = el + 1;
   559458:  477:    if ((el - c->rcurr) > 1 && *(el - 1) == '\r') {
   479437:  478:        el--;
        -:  479:    }
   559458:  480:    *el = '\0';
        -:  481:
  559458*:  482:    assert(cont <= (c->rcurr + c->rbytes));
        -:  483:
   559458:  484:    c->last_cmd_time = current_time;
   559458:  485:    process_command_ascii(c, c->rcurr);
        -:  486:
   559458:  487:    c->rbytes -= (cont - c->rcurr);
   559458:  488:    c->rcurr = cont;
        -:  489:
  559458*:  490:    assert(c->rcurr <= (c->rbuf + c->rsize));
        -:  491:
        -:  492:    return 1;
        -:  493:}
        -:  494:
        -:  495:
   313712:  496:static inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)
        -:  497:{
   313712:  498:    int noreply_index = ntokens - 2;
        -:  499:
        -:  500:    /*
        -:  501:      NOTE: this function is not the first place where we are going to
        -:  502:      send the reply.  We could send it instead from process_command()
        -:  503:      if the request line has wrong number of tokens.  However parsing
        -:  504:      malformed line for "noreply" option is not reliable anyway, so
        -:  505:      it can't be helped.
        -:  506:    */
   313712:  507:    if (tokens[noreply_index].value
   313712:  508:        && strcmp(tokens[noreply_index].value, "noreply") == 0) {
   162851:  509:        c->noreply = true;
        -:  510:    }
   313712:  511:    return c->noreply;
        -:  512:}
        -:  513:
        -:  514:/* client flags == 0 means use no storage for client flags */
    50552:  515:static inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas, int nbytes) {
    50552:  516:    char *p = suffix;
    50552:  517:    *p = ' ';
    50552:  518:    p++;
    50552:  519:    if (FLAGS_SIZE(it) == 0) {
    50548:  520:        *p = '0';
    50548:  521:        p++;
        -:  522:    } else {
        4:  523:        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);
        -:  524:    }
    50552:  525:    *p = ' ';
    50552:  526:    p = itoa_u32(nbytes-2, p+1);
        -:  527:
    50552:  528:    if (return_cas) {
       19:  529:        *p = ' ';
       19:  530:        p = itoa_u64(ITEM_get_cas(it), p+1);
        -:  531:    }
        -:  532:
    50552:  533:    *p = '\r';
    50552:  534:    *(p+1) = '\n';
    50552:  535:    *(p+2) = '\0';
    50552:  536:    return (p - suffix) + 2;
        -:  537:}
        -:  538:
        -:  539:/* ntokens is overwritten here... shrug.. */
   112690:  540:static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {
   112690:  541:    char *key;
   112690:  542:    size_t nkey;
   112690:  543:    item *it;
   112690:  544:    token_t *key_token = &tokens[KEY_TOKEN];
   112690:  545:    int32_t exptime_int = 0;
   112690:  546:    rel_time_t exptime = 0;
   112690:  547:    bool fail_length = false;
  112690*:  548:    assert(c != NULL);
   112690:  549:    mc_resp *resp = c->resp;
        -:  550:
   112690:  551:    if (should_touch) {
        -:  552:        // For get and touch commands, use first token as exptime
        6:  553:        if (!safe_strtol(tokens[1].value, &exptime_int)) {
    #####:  554:            out_string(c, "CLIENT_ERROR invalid exptime argument");
    #####:  555:            return;
        -:  556:        }
        6:  557:        key_token++;
       11:  558:        exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));
        -:  559:    }
        -:  560:
        -:  561:    do {
   245690:  562:        while(key_token->length != 0) {
   132160:  563:            bool overflow; // not used here.
   132160:  564:            key = key_token->value;
   132160:  565:            nkey = key_token->length;
        -:  566:
   132160:  567:            if (nkey > KEY_MAX_LENGTH) {
        2:  568:                fail_length = true;
        4:  569:                goto stop;
        -:  570:            }
        -:  571:
   132158:  572:            it = limited_get(key, nkey, c, exptime, should_touch, DO_UPDATE, &overflow);
   132158:  573:            if (settings.detail_enabled) {
        3:  574:                stats_prefix_record_get(key, nkey, NULL != it);
        -:  575:            }
   132158:  576:            if (it) {
        -:  577:                /*
        -:  578:                 * Construct the response. Each hit adds three elements to the
        -:  579:                 * outgoing data list:
        -:  580:                 *   "VALUE "
        -:  581:                 *   key
        -:  582:                 *   " " + flags + " " + data length + "\r\n" + data (with \r\n)
        -:  583:                 */
        -:  584:
        -:  585:                {
        -:  586:                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
    50552:  587:                                        it->nbytes, ITEM_get_cas(it));
    50552:  588:                  int nbytes = it->nbytes;;
    50552:  589:                  nbytes = it->nbytes;
    50552:  590:                  char *p = resp->wbuf;
    50552:  591:                  memcpy(p, "VALUE ", 6);
    50552:  592:                  p += 6;
    50552:  593:                  memcpy(p, ITEM_key(it), it->nkey);
    50552:  594:                  p += it->nkey;
    50552:  595:                  p += make_ascii_get_suffix(p, it, return_cas, nbytes);
    50552:  596:                  resp_add_iov(resp, resp->wbuf, p - resp->wbuf);
        -:  597:
        -:  598:#ifdef EXTSTORE
    50552:  599:                  if (it->it_flags & ITEM_HDR) {
      353:  600:                      if (storage_get_item(c, it, resp) != 0) {
        1:  601:                          pthread_mutex_lock(&c->thread->stats.mutex);
        1:  602:                          c->thread->stats.get_oom_extstore++;
        1:  603:                          pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  604:
        1:  605:                          item_remove(it);
        1:  606:                          goto stop;
        -:  607:                      }
    50199:  608:                  } else if ((it->it_flags & ITEM_CHUNKED) == 0) {
    31779:  609:                      resp_add_iov(resp, ITEM_data(it), it->nbytes);
        -:  610:                  } else {
    18420:  611:                      resp_add_chunked_iov(resp, it, it->nbytes);
        -:  612:                  }
        -:  613:#else
        -:  614:                  if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -:  615:                      resp_add_iov(resp, ITEM_data(it), it->nbytes);
        -:  616:                  } else {
        -:  617:                      resp_add_chunked_iov(resp, it, it->nbytes);
        -:  618:                  }
        -:  619:#endif
        -:  620:                }
        -:  621:
    50551:  622:                if (settings.verbose > 1) {
    #####:  623:                    int ii;
    #####:  624:                    fprintf(stderr, ">%d sending key ", c->sfd);
    #####:  625:                    for (ii = 0; ii < it->nkey; ++ii) {
    #####:  626:                        fprintf(stderr, "%c", key[ii]);
        -:  627:                    }
    #####:  628:                    fprintf(stderr, "\n");
        -:  629:                }
        -:  630:
        -:  631:                /* item_get() has incremented it->refcount for us */
    50551:  632:                pthread_mutex_lock(&c->thread->stats.mutex);
    50551:  633:                if (should_touch) {
        7:  634:                    c->thread->stats.touch_cmds++;
        7:  635:                    c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        -:  636:                } else {
    50544:  637:                    c->thread->stats.lru_hits[it->slabs_clsid]++;
    50544:  638:                    c->thread->stats.get_cmds++;
        -:  639:                }
    50551:  640:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  641:#ifdef EXTSTORE
        -:  642:                /* If ITEM_HDR, an io_wrap owns the reference. */
    50551:  643:                if ((it->it_flags & ITEM_HDR) == 0) {
    50199:  644:                    resp->item = it;
        -:  645:                }
        -:  646:#else
        -:  647:                resp->item = it;
        -:  648:#endif
        -:  649:            } else {
    81606:  650:                pthread_mutex_lock(&c->thread->stats.mutex);
    81606:  651:                if (should_touch) {
        1:  652:                    c->thread->stats.touch_cmds++;
        1:  653:                    c->thread->stats.touch_misses++;
        -:  654:                } else {
    81605:  655:                    c->thread->stats.get_misses++;
    81605:  656:                    c->thread->stats.get_cmds++;
        -:  657:                }
    81606:  658:                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
    81606:  659:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  660:            }
        -:  661:
   132157:  662:            key_token++;
   132157:  663:            if (key_token->length != 0) {
    18627:  664:                if (!resp_start(c)) {
        1:  665:                    goto stop;
        -:  666:                }
    18626:  667:                resp = c->resp;
        -:  668:            }
        -:  669:        }
        -:  670:
        -:  671:        /*
        -:  672:         * If the command string hasn't been fully processed, get the next set
        -:  673:         * of tokens.
        -:  674:         */
   113530:  675:        if (key_token->value != NULL) {
      844:  676:            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
      844:  677:            key_token = tokens;
      844:  678:            if (!resp_start(c)) {
    #####:  679:                goto stop;
        -:  680:            }
      844:  681:            resp = c->resp;
        -:  682:        }
   113530:  683:    } while(key_token->value != NULL);
   112686:  684:stop:
        -:  685:
   112690:  686:    if (settings.verbose > 1)
    #####:  687:        fprintf(stderr, ">%d END\n", c->sfd);
        -:  688:
        -:  689:    /*
        -:  690:        If the loop was terminated because of out-of-memory, it is not
        -:  691:        reliable to add END\r\n to the buffer, because it might not end
        -:  692:        in \r\n. So we send SERVER_ERROR instead.
        -:  693:    */
   112690:  694:    if (key_token->value != NULL) {
        -:  695:        // Kill any stacked responses we had.
        4:  696:        conn_release_items(c);
        -:  697:        // Start a new response object for the error message.
        4:  698:        if (!resp_start(c)) {
        -:  699:            // severe out of memory error.
    #####:  700:            conn_set_state(c, conn_closing);
    #####:  701:            return;
        -:  702:        }
        4:  703:        if (fail_length) {
        2:  704:            out_string(c, "CLIENT_ERROR bad command line format");
        -:  705:        } else {
        2:  706:            out_of_memory(c, "SERVER_ERROR out of memory writing get response");
        -:  707:        }
        -:  708:    } else {
        -:  709:        // Tag the end token onto the most recent response object.
   112686:  710:        resp_add_iov(resp, "END\r\n", 5);
   112686:  711:        conn_set_state(c, conn_mwrite);
        -:  712:    }
        -:  713:}
        -:  714:
       10:  715:inline static void process_stats_detail(conn *c, const char *command) {
      10*:  716:    assert(c != NULL);
        -:  717:
       10:  718:    if (strcmp(command, "on") == 0) {
        1:  719:        settings.detail_enabled = 1;
        1:  720:        out_string(c, "OK");
        -:  721:    }
        9:  722:    else if (strcmp(command, "off") == 0) {
        1:  723:        settings.detail_enabled = 0;
        1:  724:        out_string(c, "OK");
        -:  725:    }
        8:  726:    else if (strcmp(command, "dump") == 0) {
        8:  727:        int len;
        8:  728:        char *stats = stats_prefix_dump(&len);
        8:  729:        write_and_free(c, stats, len);
        -:  730:    }
        -:  731:    else {
    #####:  732:        out_string(c, "CLIENT_ERROR usage: stats detail on|off|dump");
        -:  733:    }
       10:  734:}
        -:  735:
     1598:  736:static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {
     1598:  737:    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;
    1598*:  738:    assert(c != NULL);
        -:  739:
     1598:  740:    if (ntokens < 2) {
    #####:  741:        out_string(c, "CLIENT_ERROR bad command line");
    #####:  742:        return;
        -:  743:    }
        -:  744:
     1598:  745:    if (ntokens == 2) {
     1442:  746:        server_stats(&append_stats, c);
     1442:  747:        (void)get_stats(NULL, 0, &append_stats, c);
      156:  748:    } else if (strcmp(subcommand, "reset") == 0) {
        3:  749:        stats_reset();
        3:  750:        out_string(c, "RESET");
        3:  751:        return;
      153:  752:    } else if (strcmp(subcommand, "detail") == 0) {
        -:  753:        /* NOTE: how to tackle detail with binary? */
       10:  754:        if (ntokens < 4)
    #####:  755:            process_stats_detail(c, "");  /* outputs the error message */
        -:  756:        else
       10:  757:            process_stats_detail(c, tokens[2].value);
        -:  758:        /* Output already generated */
       10:  759:        return;
      143:  760:    } else if (strcmp(subcommand, "settings") == 0) {
       18:  761:        process_stat_settings(&append_stats, c);
      125:  762:    } else if (strcmp(subcommand, "cachedump") == 0) {
        3:  763:        char *buf;
        3:  764:        unsigned int bytes, id, limit = 0;
        -:  765:
        3:  766:        if (!settings.dump_enabled) {
    #####:  767:            out_string(c, "CLIENT_ERROR stats cachedump not allowed");
    #####:  768:            return;
        -:  769:        }
        -:  770:
        3:  771:        if (ntokens < 5) {
    #####:  772:            out_string(c, "CLIENT_ERROR bad command line");
    #####:  773:            return;
        -:  774:        }
        -:  775:
        6:  776:        if (!safe_strtoul(tokens[2].value, &id) ||
        3:  777:            !safe_strtoul(tokens[3].value, &limit)) {
    #####:  778:            out_string(c, "CLIENT_ERROR bad command line format");
    #####:  779:            return;
        -:  780:        }
        -:  781:
        3:  782:        if (id >= MAX_NUMBER_OF_SLAB_CLASSES) {
        1:  783:            out_string(c, "CLIENT_ERROR Illegal slab id");
        1:  784:            return;
        -:  785:        }
        -:  786:
        2:  787:        buf = item_cachedump(id, limit, &bytes);
        2:  788:        write_and_free(c, buf, bytes);
        2:  789:        return;
      122:  790:    } else if (strcmp(subcommand, "conns") == 0) {
        4:  791:        process_stats_conns(&append_stats, c);
        -:  792:#ifdef EXTSTORE
      118:  793:    } else if (strcmp(subcommand, "extstore") == 0) {
    #####:  794:        process_extstore_stats(&append_stats, c);
        -:  795:#endif
        -:  796:#ifdef PROXY
        -:  797:    } else if (strcmp(subcommand, "proxy") == 0) {
        -:  798:        process_proxy_stats(&append_stats, c);
        -:  799:#endif
        -:  800:    } else {
        -:  801:        /* getting here means that the subcommand is either engine specific or
        -:  802:           is invalid. query the engine and see. */
      118:  803:        if (get_stats(subcommand, strlen(subcommand), &append_stats, c)) {
      118:  804:            if (c->stats.buffer == NULL) {
    #####:  805:                out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -:  806:            } else {
      118:  807:                write_and_free(c, c->stats.buffer, c->stats.offset);
      118:  808:                c->stats.buffer = NULL;
        -:  809:            }
        -:  810:        } else {
    #####:  811:            out_string(c, "ERROR");
        -:  812:        }
      118:  813:        return;
        -:  814:    }
        -:  815:
        -:  816:    /* append terminator and start the transfer */
     1464:  817:    append_stats(NULL, 0, NULL, 0, c);
        -:  818:
     1464:  819:    if (c->stats.buffer == NULL) {
    #####:  820:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -:  821:    } else {
     1464:  822:        write_and_free(c, c->stats.buffer, c->stats.offset);
     1464:  823:        c->stats.buffer = NULL;
        -:  824:    }
        -:  825:}
        -:  826:
        -:  827:// slow snprintf for debugging purposes.
        2:  828:static void process_meta_command(conn *c, token_t *tokens, const size_t ntokens) {
       2*:  829:    assert(c != NULL);
        -:  830:
        2:  831:    if (ntokens < 3 || tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####:  832:        out_string(c, "CLIENT_ERROR bad command line format");
    #####:  833:        return;
        -:  834:    }
        -:  835:
        2:  836:    char *key = tokens[KEY_TOKEN].value;
        2:  837:    size_t nkey = tokens[KEY_TOKEN].length;
        -:  838:
       2*:  839:    if (ntokens >= 4 && tokens[2].length == 1 && tokens[2].value[0] == 'b') {
    #####:  840:        size_t ret = base64_decode((unsigned char *)key, nkey,
        -:  841:                    (unsigned char *)key, nkey);
    #####:  842:        if (ret == 0) {
        -:  843:            // failed to decode.
    #####:  844:            out_string(c, "CLIENT_ERROR bad command line format");
    #####:  845:            return;
        -:  846:        }
        -:  847:        nkey = ret;
        -:  848:    }
        -:  849:
        2:  850:    bool overflow; // not used here.
        2:  851:    item *it = limited_get(key, nkey, c, 0, false, DONT_UPDATE, &overflow);
        2:  852:    if (it) {
        1:  853:        mc_resp *resp = c->resp;
        1:  854:        size_t total = 0;
        1:  855:        size_t ret;
        -:  856:        // similar to out_string().
        1:  857:        memcpy(resp->wbuf, "ME ", 3);
        1:  858:        total += 3;
        1:  859:        if (it->it_flags & ITEM_KEY_BINARY) {
        -:  860:            // re-encode from memory rather than copy the original key;
        -:  861:            // to help give confidence that what in memory is what we asked
        -:  862:            // for.
    #####:  863:            total += base64_encode((unsigned char *) ITEM_key(it), it->nkey, (unsigned char *)resp->wbuf + total, WRITE_BUFFER_SIZE - total);
        -:  864:        } else {
        1:  865:            memcpy(resp->wbuf + total, ITEM_key(it), it->nkey);
        1:  866:            total += it->nkey;
        -:  867:        }
        1:  868:        resp->wbuf[total] = ' ';
        1:  869:        total++;
        -:  870:
       2*:  871:        ret = snprintf(resp->wbuf + total, WRITE_BUFFER_SIZE - (it->nkey + 12),
        -:  872:                "exp=%d la=%llu cas=%llu fetch=%s cls=%u size=%lu\r\n",
    #####:  873:                (it->exptime == 0) ? -1 : (current_time - it->exptime),
        1:  874:                (unsigned long long)(current_time - it->time),
        -:  875:                (unsigned long long)ITEM_get_cas(it),
        -:  876:                (it->it_flags & ITEM_FETCHED) ? "yes" : "no",
        1:  877:                ITEM_clsid(it),
        1:  878:                (unsigned long) ITEM_ntotal(it));
        -:  879:
        1:  880:        item_remove(it);
        1:  881:        resp->wbytes = total + ret;
        1:  882:        resp_add_iov(resp, resp->wbuf, resp->wbytes);
        1:  883:        conn_set_state(c, conn_new_cmd);
        -:  884:    } else {
        1:  885:        out_string(c, "EN");
        -:  886:    }
        2:  887:    pthread_mutex_lock(&c->thread->stats.mutex);
        2:  888:    c->thread->stats.meta_cmds++;
        2:  889:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  890:}
        -:  891:
        -:  892:#define MFLAG_MAX_OPT_LENGTH 20
        -:  893:#define MFLAG_MAX_OPAQUE_LENGTH 32
        -:  894:
        -:  895:struct _meta_flags {
        -:  896:    unsigned int has_error :1; // flipped if we found an error during parsing.
        -:  897:    unsigned int no_update :1;
        -:  898:    unsigned int locked :1;
        -:  899:    unsigned int vivify :1;
        -:  900:    unsigned int la :1;
        -:  901:    unsigned int hit :1;
        -:  902:    unsigned int value :1;
        -:  903:    unsigned int set_stale :1;
        -:  904:    unsigned int no_reply :1;
        -:  905:    unsigned int has_cas :1;
        -:  906:    unsigned int new_ttl :1;
        -:  907:    unsigned int key_binary:1;
        -:  908:    char mode; // single character mode switch, common to ms/ma
        -:  909:    rel_time_t exptime;
        -:  910:    rel_time_t autoviv_exptime;
        -:  911:    rel_time_t recache_time;
        -:  912:    uint32_t client_flags;
        -:  913:    uint64_t req_cas_id;
        -:  914:    uint64_t delta; // ma
        -:  915:    uint64_t initial; // ma
        -:  916:};
        -:  917:
      104:  918:static int _meta_flag_preparse(token_t *tokens, const size_t start,
        -:  919:        struct _meta_flags *of, char **errstr) {
      104:  920:    unsigned int i;
      104:  921:    size_t ret;
      104:  922:    int32_t tmp_int;
      104:  923:    uint8_t seen[127] = {0};
        -:  924:    // Start just past the key token. Look at first character of each token.
      333:  925:    for (i = start; tokens[i].length != 0; i++) {
      230:  926:        uint8_t o = (uint8_t)tokens[i].value[0];
        -:  927:        // zero out repeat flags so we don't over-parse for return data.
      230:  928:        if (o >= 127 || seen[o] != 0) {
    #####:  929:            *errstr = "CLIENT_ERROR duplicate flag";
    #####:  930:            return -1;
        -:  931:        }
      230:  932:        seen[o] = 1;
      230:  933:        switch (o) {
        -:  934:            // base64 decode the key in-place, as the binary should always be
        -:  935:            // shorter and the conversion code buffers bytes.
        2:  936:            case 'b':
        4:  937:                ret = base64_decode((unsigned char *)tokens[KEY_TOKEN].value, tokens[KEY_TOKEN].length,
        2:  938:                            (unsigned char *)tokens[KEY_TOKEN].value, tokens[KEY_TOKEN].length);
        2:  939:                if (ret == 0) {
        -:  940:                    // Failed to decode
    #####:  941:                    *errstr = "CLIENT_ERROR error decoding key";
    #####:  942:                    of->has_error = 1;
        -:  943:                }
        2:  944:                tokens[KEY_TOKEN].length = ret;
        2:  945:                of->key_binary = 1;
        2:  946:                break;
        -:  947:            /* Negative exptimes can underflow and end up immortal. realtime() will
        -:  948:               immediately expire values that are greater than REALTIME_MAXDELTA, but less
        -:  949:               than process_started, so lets aim for that. */
       16:  950:            case 'N':
       16:  951:                of->locked = 1;
       16:  952:                of->vivify = 1;
       16:  953:                if (!safe_strtol(tokens[i].value+1, &tmp_int)) {
    #####:  954:                    *errstr = "CLIENT_ERROR bad token in command line format";
    #####:  955:                    of->has_error = 1;
        -:  956:                } else {
       32:  957:                    of->autoviv_exptime = realtime(EXPTIME_TO_POSITIVE_TIME(tmp_int));
        -:  958:                }
        -:  959:                break;
       25:  960:            case 'T':
       25:  961:                of->locked = 1;
       25:  962:                if (!safe_strtol(tokens[i].value+1, &tmp_int)) {
    #####:  963:                    *errstr = "CLIENT_ERROR bad token in command line format";
    #####:  964:                    of->has_error = 1;
        -:  965:                } else {
       50:  966:                    of->exptime = realtime(EXPTIME_TO_POSITIVE_TIME(tmp_int));
       25:  967:                    of->new_ttl = true;
        -:  968:                }
        -:  969:                break;
        2:  970:            case 'R':
        2:  971:                of->locked = 1;
        2:  972:                if (!safe_strtol(tokens[i].value+1, &tmp_int)) {
    #####:  973:                    *errstr = "CLIENT_ERROR bad token in command line format";
    #####:  974:                    of->has_error = 1;
        -:  975:                } else {
        4:  976:                    of->recache_time = realtime(EXPTIME_TO_POSITIVE_TIME(tmp_int));
        -:  977:                }
        -:  978:                break;
        1:  979:            case 'l':
        1:  980:                of->la = 1;
        1:  981:                of->locked = 1; // need locked to delay LRU bump
        1:  982:                break;
        -:  983:            case 'O':
        -:  984:            case 'P':
        -:  985:            case 'L':
        -:  986:                break;
        -:  987:            case 'k': // known but no special handling
        -:  988:            case 's':
        -:  989:            case 't':
        -:  990:            case 'c':
        -:  991:            case 'f':
        -:  992:                break;
       52:  993:            case 'v':
       52:  994:                of->value = 1;
       52:  995:                break;
        5:  996:            case 'h':
        5:  997:                of->locked = 1; // need locked to delay LRU bump
        5:  998:                break;
        2:  999:            case 'u':
        2: 1000:                of->no_update = 1;
        2: 1001:                break;
       10: 1002:            case 'q':
       10: 1003:                of->no_reply = 1;
       10: 1004:                break;
        -: 1005:            // mset-related.
    #####: 1006:            case 'F':
    #####: 1007:                if (!safe_strtoul(tokens[i].value+1, &of->client_flags)) {
    #####: 1008:                    of->has_error = true;
        -: 1009:                }
        -: 1010:                break;
       12: 1011:            case 'C': // mset, mdelete, marithmetic
       12: 1012:                if (!safe_strtoull(tokens[i].value+1, &of->req_cas_id)) {
    #####: 1013:                    *errstr = "CLIENT_ERROR bad token in command line format";
    #####: 1014:                    of->has_error = true;
        -: 1015:                } else {
       12: 1016:                    of->has_cas = true;
        -: 1017:                }
        -: 1018:                break;
       10: 1019:            case 'M': // mset and marithmetic mode switch
       10: 1020:                if (tokens[i].length != 2) {
    #####: 1021:                    *errstr = "CLIENT_ERROR incorrect length for M token";
    #####: 1022:                    of->has_error = 1;
        -: 1023:                } else {
       10: 1024:                    of->mode = tokens[i].value[1];
        -: 1025:                }
        -: 1026:                break;
        5: 1027:            case 'J': // marithmetic initial value
        5: 1028:                if (!safe_strtoull(tokens[i].value+1, &of->initial)) {
    #####: 1029:                    *errstr = "CLIENT_ERROR invalid numeric initial value";
    #####: 1030:                    of->has_error = 1;
        -: 1031:                }
        -: 1032:                break;
        5: 1033:            case 'D': // marithmetic delta value
        5: 1034:                if (!safe_strtoull(tokens[i].value+1, &of->delta)) {
    #####: 1035:                    *errstr = "CLIENT_ERROR invalid numeric delta value";
    #####: 1036:                    of->has_error = 1;
        -: 1037:                }
        -: 1038:                break;
        2: 1039:            case 'I':
        2: 1040:                of->set_stale = 1;
        2: 1041:                break;
        1: 1042:            default: // unknown flag, bail.
        1: 1043:                *errstr = "CLIENT_ERROR invalid flag";
        1: 1044:                return -1;
        -: 1045:        }
        -: 1046:    }
        -: 1047:
      103: 1048:    return of->has_error ? -1 : 0;
        -: 1049:}
        -: 1050:
       56: 1051:static void process_mget_command(conn *c, token_t *tokens, const size_t ntokens) {
       56: 1052:    char *key;
       56: 1053:    size_t nkey;
       56: 1054:    item *it;
       56: 1055:    unsigned int i = 0;
       56: 1056:    struct _meta_flags of = {0}; // option bitflags.
       56: 1057:    uint32_t hv; // cached hash value for unlocking an item.
       56: 1058:    bool failed = false;
       56: 1059:    bool item_created = false;
       56: 1060:    bool won_token = false;
       56: 1061:    bool ttl_set = false;
       56: 1062:    char *errstr = "CLIENT_ERROR bad command line format";
      56*: 1063:    assert(c != NULL);
       56: 1064:    mc_resp *resp = c->resp;
       56: 1065:    char *p = resp->wbuf;
        -: 1066:
     112*: 1067:    WANT_TOKENS_MIN(ntokens, 3);
        -: 1068:
        -: 1069:    // FIXME: do we move this check to after preparse?
       56: 1070:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 1071:        out_errstring(c, "CLIENT_ERROR bad command line format");
    #####: 1072:        return;
        -: 1073:    }
        -: 1074:
        -: 1075:    // NOTE: final token has length == 0.
        -: 1076:    // KEY_TOKEN == 1. 0 is command.
        -: 1077:
       56: 1078:    if (ntokens == 3) {
        -: 1079:        // TODO: any way to fix this?
    #####: 1080:        out_errstring(c, "CLIENT_ERROR bad command line format");
    #####: 1081:        return;
       56: 1082:    } else if (ntokens > MFLAG_MAX_OPT_LENGTH) {
        -: 1083:        // TODO: ensure the command tokenizer gives us at least this many
    #####: 1084:        out_errstring(c, "CLIENT_ERROR options flags are too long");
    #####: 1085:        return;
        -: 1086:    }
        -: 1087:
        -: 1088:    // scrubs duplicated options and sets flags for how to load the item.
        -: 1089:    // we pass in the first token that should be a flag.
       56: 1090:    if (_meta_flag_preparse(tokens, 2, &of, &errstr) != 0) {
        1: 1091:        out_errstring(c, errstr);
        1: 1092:        return;
        -: 1093:    }
       55: 1094:    c->noreply = of.no_reply;
        -: 1095:
        -: 1096:    // Grab key and length after meta preparsing in case it was decoded.
       55: 1097:    key = tokens[KEY_TOKEN].value;
       55: 1098:    nkey = tokens[KEY_TOKEN].length;
        -: 1099:
        -: 1100:    // TODO: need to indicate if the item was overflowed or not?
        -: 1101:    // I think we do, since an overflow shouldn't trigger an alloc/replace.
       55: 1102:    bool overflow = false;
       55: 1103:    if (!of.locked) {
       41: 1104:        it = limited_get(key, nkey, c, 0, false, !of.no_update, &overflow);
        -: 1105:    } else {
        -: 1106:        // If we had to lock the item, we're doing our own bump later.
       14: 1107:        it = limited_get_locked(key, nkey, c, DONT_UPDATE, &hv, &overflow);
        -: 1108:    }
        -: 1109:
        -: 1110:    // Since we're a new protocol, we can actually inform users that refcount
        -: 1111:    // overflow is happening by straight up throwing an error.
        -: 1112:    // We definitely don't want to re-autovivify by accident.
       55: 1113:    if (overflow) {
    #####: 1114:        assert(it == NULL);
    #####: 1115:        out_errstring(c, "SERVER_ERROR refcount overflow during fetch");
    #####: 1116:        return;
        -: 1117:    }
        -: 1118:
       55: 1119:    if (it == NULL && of.vivify) {
        -: 1120:        // Fill in the exptime during parsing later.
        2: 1121:        it = item_alloc(key, nkey, 0, realtime(0), 2);
        -: 1122:        // We don't actually need any of do_store_item's logic:
        -: 1123:        // - already fetched and missed an existing item.
        -: 1124:        // - lock is still held.
        -: 1125:        // - not append/prepend/replace
        -: 1126:        // - not testing CAS
        2: 1127:        if (it != NULL) {
        -: 1128:            // I look forward to the day I get rid of this :)
        2: 1129:            memcpy(ITEM_data(it), "\r\n", 2);
        -: 1130:            // NOTE: This initializes the CAS value.
        2: 1131:            do_item_link(it, hv);
        2: 1132:            item_created = true;
        -: 1133:        }
        -: 1134:    }
        -: 1135:
        -: 1136:    // don't have to check result of add_iov() since the iov size defaults are
        -: 1137:    // enough.
       55: 1138:    if (it) {
       37: 1139:        if (of.value) {
       25: 1140:            memcpy(p, "VA ", 3);
       25: 1141:            p = itoa_u32(it->nbytes-2, p+3);
        -: 1142:        } else {
       12: 1143:            if (settings.meta_response_old) {
    #####: 1144:                memcpy(p, "OK", 2);
        -: 1145:            } else {
       12: 1146:                memcpy(p, "HD", 2);
        -: 1147:            }
       12: 1148:            p += 2;
        -: 1149:        }
        -: 1150:
      152: 1151:        for (i = KEY_TOKEN+1; i < ntokens-1; i++) {
      115: 1152:            switch (tokens[i].value[0]) {
        1: 1153:                case 'T':
        1: 1154:                    ttl_set = true;
        1: 1155:                    it->exptime = of.exptime;
        1: 1156:                    break;
        7: 1157:                case 'N':
        7: 1158:                    if (item_created) {
        2: 1159:                        it->exptime = of.autoviv_exptime;
        2: 1160:                        won_token = true;
        -: 1161:                    }
        -: 1162:                    break;
        2: 1163:                case 'R':
        -: 1164:                    // If we haven't autovivified and supplied token is less
        -: 1165:                    // than current TTL, mark a win.
        2: 1166:                    if ((it->it_flags & ITEM_TOKEN_SENT) == 0
        1: 1167:                            && !item_created
        1: 1168:                            && it->exptime != 0
        1: 1169:                            && it->exptime < of.recache_time) {
        1: 1170:                        won_token = true;
        -: 1171:                    }
        -: 1172:                    break;
       31: 1173:                case 's':
       31: 1174:                    META_CHAR(p, 's');
       31: 1175:                    p = itoa_u32(it->nbytes-2, p);
       31: 1176:                    break;
       21: 1177:                case 't':
        -: 1178:                    // TTL remaining as of this request.
        -: 1179:                    // needs to be relative because server clocks may not be in sync.
       21: 1180:                    META_CHAR(p, 't');
       21: 1181:                    if (it->exptime == 0) {
    #####: 1182:                        *p = '-';
    #####: 1183:                        *(p+1) = '1';
    #####: 1184:                        p += 2;
        -: 1185:                    } else {
       21: 1186:                        p = itoa_u32(it->exptime - current_time, p);
        -: 1187:                    }
        -: 1188:                    break;
       11: 1189:                case 'c':
       11: 1190:                    META_CHAR(p, 'c');
       11: 1191:                    p = itoa_u64(ITEM_get_cas(it), p);
       11: 1192:                    break;
    #####: 1193:                case 'f':
    #####: 1194:                    META_CHAR(p, 'f');
    #####: 1195:                    if (FLAGS_SIZE(it) == 0) {
    #####: 1196:                        *p = '0';
    #####: 1197:                        p++;
        -: 1198:                    } else {
    #####: 1199:                        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);
        -: 1200:                    }
        -: 1201:                    break;
        1: 1202:                case 'l':
        1: 1203:                    META_CHAR(p, 'l');
        1: 1204:                    p = itoa_u32(current_time - it->time, p);
        1: 1205:                    break;
        5: 1206:                case 'h':
        5: 1207:                    META_CHAR(p, 'h');
        5: 1208:                    if (it->it_flags & ITEM_FETCHED) {
        2: 1209:                        *p = '1';
        -: 1210:                    } else {
        3: 1211:                        *p = '0';
        -: 1212:                    }
        5: 1213:                    p++;
        5: 1214:                    break;
        2: 1215:                case 'O':
        2: 1216:                    if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {
    #####: 1217:                        errstr = "CLIENT_ERROR opaque token too long";
    #####: 1218:                        goto error;
        -: 1219:                    }
        2: 1220:                    META_SPACE(p);
        2: 1221:                    memcpy(p, tokens[i].value, tokens[i].length);
        2: 1222:                    p += tokens[i].length;
        2: 1223:                    break;
        3: 1224:                case 'k':
        3: 1225:                    META_KEY(p, ITEM_key(it), it->nkey, (it->it_flags & ITEM_KEY_BINARY));
        -: 1226:                    break;
        -: 1227:            }
        -: 1228:        }
        -: 1229:
        -: 1230:        // Has this item already sent a token?
        -: 1231:        // Important to do this here so we don't send W with Z.
        -: 1232:        // Isn't critical, but easier for client authors to understand.
       37: 1233:        if (it->it_flags & ITEM_TOKEN_SENT) {
        3: 1234:            META_CHAR(p, 'Z');
        -: 1235:        }
       37: 1236:        if (it->it_flags & ITEM_STALE) {
        2: 1237:            META_CHAR(p, 'X');
        -: 1238:            // FIXME: think hard about this. is this a default, or a flag?
        2: 1239:            if ((it->it_flags & ITEM_TOKEN_SENT) == 0) {
        -: 1240:                // If we're stale but no token already sent, now send one.
        -: 1241:                won_token = true;
        -: 1242:            }
        -: 1243:        }
        -: 1244:
       36: 1245:        if (won_token) {
        -: 1246:            // Mark a win into the flag buffer.
        4: 1247:            META_CHAR(p, 'W');
        4: 1248:            it->it_flags |= ITEM_TOKEN_SENT;
        -: 1249:        }
        -: 1250:
       37: 1251:        *p = '\r';
       37: 1252:        *(p+1) = '\n';
       37: 1253:        *(p+2) = '\0';
       37: 1254:        p += 2;
        -: 1255:        // finally, chain in the buffer.
       37: 1256:        resp_add_iov(resp, resp->wbuf, p - resp->wbuf);
        -: 1257:
       37: 1258:        if (of.value) {
        -: 1259:#ifdef EXTSTORE
       25: 1260:            if (it->it_flags & ITEM_HDR) {
        2: 1261:                if (storage_get_item(c, it, resp) != 0) {
    #####: 1262:                    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1263:                    c->thread->stats.get_oom_extstore++;
    #####: 1264:                    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1265:
    #####: 1266:                    failed = true;
        -: 1267:                }
       23: 1268:            } else if ((it->it_flags & ITEM_CHUNKED) == 0) {
       23: 1269:                resp_add_iov(resp, ITEM_data(it), it->nbytes);
        -: 1270:            } else {
    #####: 1271:                resp_add_chunked_iov(resp, it, it->nbytes);
        -: 1272:            }
        -: 1273:#else
        -: 1274:            if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 1275:                resp_add_iov(resp, ITEM_data(it), it->nbytes);
        -: 1276:            } else {
        -: 1277:                resp_add_chunked_iov(resp, it, it->nbytes);
        -: 1278:            }
        -: 1279:#endif
        -: 1280:        }
        -: 1281:
        -: 1282:        // need to hold the ref at least because of the key above.
        -: 1283:#ifdef EXTSTORE
      23*: 1284:        if (!failed) {
       37: 1285:            if ((it->it_flags & ITEM_HDR) != 0 && of.value) {
        -: 1286:                // Only have extstore clean if header and returning value.
        2: 1287:                resp->item = NULL;
        -: 1288:            } else {
       35: 1289:                resp->item = it;
        -: 1290:            }
        -: 1291:        } else {
        -: 1292:            // Failed to set up extstore fetch.
    #####: 1293:            if (of.locked) {
    #####: 1294:                do_item_remove(it);
        -: 1295:            } else {
    #####: 1296:                item_remove(it);
        -: 1297:            }
        -: 1298:        }
        -: 1299:#else
        -: 1300:        resp->item = it;
        -: 1301:#endif
        -: 1302:    } else {
        -: 1303:        failed = true;
        -: 1304:    }
        -: 1305:
       55: 1306:    if (of.locked) {
        -: 1307:        // Delayed bump so we could get fetched/last access time pre-update.
       14: 1308:        if (!of.no_update && it != NULL) {
       12: 1309:            do_item_bump(c, it, hv);
        -: 1310:        }
       14: 1311:        item_unlock(hv);
        -: 1312:    }
        -: 1313:
        -: 1314:    // we count this command as a normal one if we've gotten this far.
        -: 1315:    // TODO: for autovivify case, miss never happens. Is this okay?
       55: 1316:    if (!failed) {
       37: 1317:        pthread_mutex_lock(&c->thread->stats.mutex);
       37: 1318:        if (ttl_set) {
        1: 1319:            c->thread->stats.touch_cmds++;
        1: 1320:            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        -: 1321:        } else {
       36: 1322:            c->thread->stats.lru_hits[it->slabs_clsid]++;
       36: 1323:            c->thread->stats.get_cmds++;
        -: 1324:        }
       37: 1325:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1326:
       37: 1327:        conn_set_state(c, conn_new_cmd);
        -: 1328:    } else {
       18: 1329:        pthread_mutex_lock(&c->thread->stats.mutex);
       18: 1330:        if (ttl_set) {
    #####: 1331:            c->thread->stats.touch_cmds++;
    #####: 1332:            c->thread->stats.touch_misses++;
        -: 1333:        } else {
       18: 1334:            c->thread->stats.get_misses++;
       18: 1335:            c->thread->stats.get_cmds++;
        -: 1336:        }
       18: 1337:        MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
       18: 1338:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1339:
        -: 1340:        // This gets elided in noreply mode.
       18: 1341:        out_string(c, "EN");
        -: 1342:    }
        -: 1343:    return;
    #####: 1344:error:
    #####: 1345:    if (it) {
    #####: 1346:        do_item_remove(it);
    #####: 1347:        if (of.locked) {
    #####: 1348:            item_unlock(hv);
        -: 1349:        }
        -: 1350:    }
    #####: 1351:    out_errstring(c, errstr);
        -: 1352:}
        -: 1353:
       30: 1354:static void process_mset_command(conn *c, token_t *tokens, const size_t ntokens) {
       30: 1355:    char *key;
       30: 1356:    size_t nkey;
       30: 1357:    item *it;
       30: 1358:    int i;
       30: 1359:    short comm = NREAD_SET;
       30: 1360:    struct _meta_flags of = {0}; // option bitflags.
       30: 1361:    char *errstr = "CLIENT_ERROR bad command line format";
       30: 1362:    uint32_t hv; // cached hash value.
       30: 1363:    int vlen = 0; // value from data line.
      30*: 1364:    assert(c != NULL);
       30: 1365:    mc_resp *resp = c->resp;
       30: 1366:    char *p = resp->wbuf;
        -: 1367:
      59*: 1368:    WANT_TOKENS_MIN(ntokens, 3);
        -: 1369:
        -: 1370:    // TODO: most of this is identical to mget.
       30: 1371:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 1372:        out_errstring(c, "CLIENT_ERROR bad command line format");
    #####: 1373:        return;
        -: 1374:    }
        -: 1375:
       30: 1376:    if (ntokens == 3) {
        1: 1377:        out_errstring(c, "CLIENT_ERROR bad command line format");
        1: 1378:        return;
        -: 1379:    }
        -: 1380:
       29: 1381:    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
    #####: 1382:        out_errstring(c, "CLIENT_ERROR options flags too long");
    #####: 1383:        return;
        -: 1384:    }
        -: 1385:
        -: 1386:    // We note tokens into the front of the write buffer, so we can create the
        -: 1387:    // final buffer in complete_nread_ascii.
       29: 1388:    p = resp->wbuf;
        -: 1389:
       29: 1390:    if (!safe_strtol(tokens[KEY_TOKEN + 1].value, (int32_t*)&vlen)) {
    #####: 1391:        out_errstring(c, "CLIENT_ERROR bad command line format");
    #####: 1392:        return;
        -: 1393:    }
        -: 1394:
       29: 1395:    if (vlen < 0 || vlen > (INT_MAX - 2)) {
    #####: 1396:        out_errstring(c, "CLIENT_ERROR bad command line format");
    #####: 1397:        return;
        -: 1398:    }
       29: 1399:    vlen += 2;
        -: 1400:
        -: 1401:    // We need to at least try to get the size to properly slurp bad bytes
        -: 1402:    // after an error.
        -: 1403:    // we pass in the first token that should be a flag.
       29: 1404:    if (_meta_flag_preparse(tokens, 3, &of, &errstr) != 0) {
    #####: 1405:        goto error;
        -: 1406:    }
        -: 1407:
       29: 1408:    key = tokens[KEY_TOKEN].value;
       29: 1409:    nkey = tokens[KEY_TOKEN].length;
        -: 1410:
        -: 1411:    // Set noreply after tokens are understood.
       29: 1412:    c->noreply = of.no_reply;
        -: 1413:    // Clear cas return value
       29: 1414:    c->cas = 0;
        -: 1415:
       29: 1416:    bool has_error = false;
      102: 1417:    for (i = KEY_TOKEN+1; i < ntokens-1; i++) {
       73: 1418:        switch (tokens[i].value[0]) {
        -: 1419:            // TODO: macro perhaps?
    #####: 1420:            case 'O':
    #####: 1421:                if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {
    #####: 1422:                    errstr = "CLIENT_ERROR opaque token too long";
    #####: 1423:                    has_error = true;
    #####: 1424:                    break;
        -: 1425:                }
    #####: 1426:                META_SPACE(p);
    #####: 1427:                memcpy(p, tokens[i].value, tokens[i].length);
    #####: 1428:                p += tokens[i].length;
    #####: 1429:                break;
    #####: 1430:            case 'k':
    #####: 1431:                META_CHAR(p, 'k');
    #####: 1432:                break;
        2: 1433:            case 'c':
        -: 1434:                // need to set the cas value post-assignment.
        2: 1435:                META_CHAR(p, 'c');
        2: 1436:                break;
        -: 1437:        }
        -: 1438:    }
        -: 1439:
        -: 1440:    // "mode switch" to alternative commands
       29: 1441:    switch (of.mode) {
        -: 1442:        case 0:
        -: 1443:            break; // no mode supplied.
        2: 1444:        case 'E': // Add...
        2: 1445:            comm = NREAD_ADD;
        2: 1446:            break;
        1: 1447:        case 'A': // Append.
        1: 1448:            comm = NREAD_APPEND;
        1: 1449:            break;
        1: 1450:        case 'P': // Prepend.
        1: 1451:            comm = NREAD_PREPEND;
        1: 1452:            break;
        2: 1453:        case 'R': // Replace.
        2: 1454:            comm = NREAD_REPLACE;
        2: 1455:            break;
        -: 1456:        case 'S': // Set. Default.
        -: 1457:            comm = NREAD_SET;
        -: 1458:            break;
        1: 1459:        default:
        1: 1460:            errstr = "CLIENT_ERROR invalid mode for ms M token";
        1: 1461:            goto error;
        -: 1462:    }
        -: 1463:
        -: 1464:    // The item storage function doesn't exactly map to mset.
        -: 1465:    // If a CAS value is supplied, upgrade default SET mode to CAS mode.
        -: 1466:    // Also allows REPLACE to work, as REPLACE + CAS works the same as CAS.
        -: 1467:    // add-with-cas works the same as add; but could only LRU bump if match..
        -: 1468:    // APPEND/PREPEND allow a simplified CAS check.
       28: 1469:    if (of.has_cas && (comm == NREAD_SET || comm == NREAD_REPLACE)) {
        8: 1470:        comm = NREAD_CAS;
        -: 1471:    }
        -: 1472:
        -: 1473:    // We attempt to process as much as we can in hopes of getting a valid and
        -: 1474:    // adjusted vlen, or else the data swallowed after error will be for 0b.
       28: 1475:    if (has_error)
    #####: 1476:        goto error;
        -: 1477:
       28: 1478:    it = item_alloc(key, nkey, of.client_flags, of.exptime, vlen);
        -: 1479:
       28: 1480:    if (it == 0) {
    #####: 1481:        enum store_item_type status;
        -: 1482:        // TODO: These could be normalized codes (TL and OM). Need to
        -: 1483:        // reorganize the output stuff a bit though.
    #####: 1484:        if (! item_size_ok(nkey, of.client_flags, vlen)) {
    #####: 1485:            errstr = "SERVER_ERROR object too large for cache";
    #####: 1486:            status = TOO_LARGE;
    #####: 1487:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1488:            c->thread->stats.store_too_large++;
    #####: 1489:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1490:        } else {
    #####: 1491:            errstr = "SERVER_ERROR out of memory storing object";
    #####: 1492:            status = NO_MEMORY;
    #####: 1493:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1494:            c->thread->stats.store_no_memory++;
    #####: 1495:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1496:        }
        -: 1497:        // FIXME: LOGGER_LOG specific to mset, include options.
    #####: 1498:        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
        -: 1499:                NULL, status, comm, key, nkey, 0, 0);
        -: 1500:
        -: 1501:        /* Avoid stale data persisting in cache because we failed alloc. */
        -: 1502:        // NOTE: only if SET mode?
    #####: 1503:        it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    #####: 1504:        if (it) {
    #####: 1505:            do_item_unlink(it, hv);
    #####: 1506:            STORAGE_delete(c->thread->storage, it);
    #####: 1507:            do_item_remove(it);
        -: 1508:        }
    #####: 1509:        item_unlock(hv);
        -: 1510:
    #####: 1511:        goto error;
        -: 1512:    }
       28: 1513:    ITEM_set_cas(it, of.req_cas_id);
        -: 1514:
       28: 1515:    c->item = it;
        -: 1516:#ifdef NEED_ALIGN
        -: 1517:    if (it->it_flags & ITEM_CHUNKED) {
        -: 1518:        c->ritem = ITEM_schunk(it);
        -: 1519:    } else {
        -: 1520:        c->ritem = ITEM_data(it);
        -: 1521:    }
        -: 1522:#else
       28: 1523:    c->ritem = ITEM_data(it);
        -: 1524:#endif
       28: 1525:    c->rlbytes = it->nbytes;
       28: 1526:    c->cmd = comm;
        -: 1527:
        -: 1528:    // Prevent printing back the key in meta commands as garbage.
       28: 1529:    if (of.key_binary) {
        1: 1530:        it->it_flags |= ITEM_KEY_BINARY;
        -: 1531:    }
        -: 1532:
       28: 1533:    if (of.set_stale && comm == NREAD_CAS) {
        1: 1534:        c->set_stale = true;
        -: 1535:    }
       28: 1536:    resp->wbytes = p - resp->wbuf;
        -: 1537:    // we don't set up the iov here, instead after complete_nread_ascii when
        -: 1538:    // we have the full status code and item data.
       28: 1539:    c->mset_res = true;
       28: 1540:    conn_set_state(c, conn_nread);
       28: 1541:    return;
        1: 1542:error:
        -: 1543:    /* swallow the data line */
        1: 1544:    c->sbytes = vlen;
        -: 1545:
        -: 1546:    // Note: no errors possible after the item was successfully allocated.
        -: 1547:    // So we're just looking at dumping error codes and returning.
        1: 1548:    out_errstring(c, errstr);
        -: 1549:    // TODO: pass state in? else switching twice meh.
        1: 1550:    conn_set_state(c, conn_swallow);
        -: 1551:}
        -: 1552:
        4: 1553:static void process_mdelete_command(conn *c, token_t *tokens, const size_t ntokens) {
        4: 1554:    char *key;
        4: 1555:    size_t nkey;
        4: 1556:    item *it = NULL;
        4: 1557:    int i;
        4: 1558:    uint32_t hv;
        4: 1559:    struct _meta_flags of = {0}; // option bitflags.
        4: 1560:    char *errstr = "CLIENT_ERROR bad command line format";
       4*: 1561:    assert(c != NULL);
        4: 1562:    mc_resp *resp = c->resp;
        -: 1563:    // reserve 3 bytes for status code
        4: 1564:    char *p = resp->wbuf + 3;
        -: 1565:
       8*: 1566:    WANT_TOKENS_MIN(ntokens, 3);
        -: 1567:
        -: 1568:    // TODO: most of this is identical to mget.
        4: 1569:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 1570:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 1571:        return;
        -: 1572:    }
        -: 1573:
        4: 1574:    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
    #####: 1575:        out_string(c, "CLIENT_ERROR options flags too long");
    #####: 1576:        return;
        -: 1577:    }
        -: 1578:
        -: 1579:    // scrubs duplicated options and sets flags for how to load the item.
        -: 1580:    // we pass in the first token that should be a flag.
        -: 1581:    // FIXME: not using the preparse errstr?
        4: 1582:    if (_meta_flag_preparse(tokens, 2, &of, &errstr) != 0) {
    #####: 1583:        out_errstring(c, "CLIENT_ERROR invalid or duplicate flag");
    #####: 1584:        return;
        -: 1585:    }
        4: 1586:    assert(c != NULL);
        4: 1587:    c->noreply = of.no_reply;
        -: 1588:
        4: 1589:    key = tokens[KEY_TOKEN].value;
        4: 1590:    nkey = tokens[KEY_TOKEN].length;
        -: 1591:
        9: 1592:    for (i = KEY_TOKEN+1; i < ntokens-1; i++) {
        5: 1593:        switch (tokens[i].value[0]) {
        -: 1594:            // TODO: macro perhaps?
    #####: 1595:            case 'O':
    #####: 1596:                if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {
    #####: 1597:                    errstr = "CLIENT_ERROR opaque token too long";
    #####: 1598:                    goto error;
        -: 1599:                }
    #####: 1600:                META_SPACE(p);
    #####: 1601:                memcpy(p, tokens[i].value, tokens[i].length);
    #####: 1602:                p += tokens[i].length;
    #####: 1603:                break;
    #####: 1604:            case 'k':
    #####: 1605:                META_KEY(p, key, nkey, of.key_binary);
        -: 1606:                break;
        -: 1607:        }
        -: 1608:    }
        -: 1609:
        4: 1610:    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
        4: 1611:    if (it) {
        4: 1612:        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
        -: 1613:
        -: 1614:        // allow only deleting/marking if a CAS value matches.
        4: 1615:        if (of.has_cas && ITEM_get_cas(it) != of.req_cas_id) {
        1: 1616:            pthread_mutex_lock(&c->thread->stats.mutex);
        1: 1617:            c->thread->stats.delete_misses++;
        1: 1618:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1619:
        1: 1620:            memcpy(resp->wbuf, "EX ", 3);
        1: 1621:            goto cleanup;
        -: 1622:        }
        -: 1623:
        -: 1624:        // If we're to set this item as stale, we don't actually want to
        -: 1625:        // delete it. We mark the stale bit, bump CAS, and update exptime if
        -: 1626:        // we were supplied a new TTL.
        3: 1627:        if (of.set_stale) {
        1: 1628:            if (of.new_ttl) {
        1: 1629:                it->exptime = of.exptime;
        -: 1630:            }
        1: 1631:            it->it_flags |= ITEM_STALE;
        -: 1632:            // Also need to remove TOKEN_SENT, so next client can win.
        1: 1633:            it->it_flags &= ~ITEM_TOKEN_SENT;
        -: 1634:
        1: 1635:            ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
        -: 1636:
        -: 1637:            // Clients can noreply nominal responses.
        1: 1638:            if (c->noreply)
    #####: 1639:                resp->skip = true;
        1: 1640:            if (settings.meta_response_old) {
    #####: 1641:                memcpy(resp->wbuf, "OK ", 3);
        -: 1642:            } else {
        1: 1643:                memcpy(resp->wbuf, "HD ", 3);
        -: 1644:            }
        -: 1645:        } else {
        2: 1646:            pthread_mutex_lock(&c->thread->stats.mutex);
        2: 1647:            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
        2: 1648:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1649:
        2: 1650:            do_item_unlink(it, hv);
        2: 1651:            STORAGE_delete(c->thread->storage, it);
        2: 1652:            if (c->noreply)
        1: 1653:                resp->skip = true;
        2: 1654:            if (settings.meta_response_old) {
    #####: 1655:                memcpy(resp->wbuf, "OK ", 3);
        -: 1656:            } else {
        2: 1657:                memcpy(resp->wbuf, "HD ", 3);
        -: 1658:            }
        -: 1659:        }
        3: 1660:        goto cleanup;
        -: 1661:    } else {
    #####: 1662:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1663:        c->thread->stats.delete_misses++;
    #####: 1664:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1665:
    #####: 1666:        memcpy(resp->wbuf, "NF ", 3);
    #####: 1667:        goto cleanup;
        -: 1668:    }
        4: 1669:cleanup:
        4: 1670:    if (it) {
        4: 1671:        do_item_remove(it);
        -: 1672:    }
        -: 1673:    // Item is always returned locked, even if missing.
        4: 1674:    item_unlock(hv);
        4: 1675:    resp->wbytes = p - resp->wbuf;
        4: 1676:    memcpy(resp->wbuf + resp->wbytes, "\r\n", 2);
        4: 1677:    resp->wbytes += 2;
        4: 1678:    resp_add_iov(resp, resp->wbuf, resp->wbytes);
        4: 1679:    conn_set_state(c, conn_new_cmd);
        4: 1680:    return;
    #####: 1681:error:
    #####: 1682:    out_errstring(c, errstr);
        -: 1683:}
        -: 1684:
       15: 1685:static void process_marithmetic_command(conn *c, token_t *tokens, const size_t ntokens) {
       15: 1686:    char *key;
       15: 1687:    size_t nkey;
       15: 1688:    int i;
       15: 1689:    struct _meta_flags of = {0}; // option bitflags.
       15: 1690:    char *errstr = "CLIENT_ERROR bad command line format";
      15*: 1691:    assert(c != NULL);
       15: 1692:    mc_resp *resp = c->resp;
        -: 1693:    // no reservation (like del/set) since we post-process the status line.
       15: 1694:    char *p = resp->wbuf;
        -: 1695:
        -: 1696:    // If no argument supplied, incr or decr by one.
       15: 1697:    of.delta = 1;
       15: 1698:    of.initial = 0; // redundant, for clarity.
       15: 1699:    bool incr = true; // default mode is to increment.
       15: 1700:    bool locked = false;
       15: 1701:    uint32_t hv = 0;
       15: 1702:    item *it = NULL; // item returned by do_add_delta.
        -: 1703:
      29*: 1704:    WANT_TOKENS_MIN(ntokens, 3);
        -: 1705:
        -: 1706:    // TODO: most of this is identical to mget.
       15: 1707:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 1708:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 1709:        return;
        -: 1710:    }
        -: 1711:
       15: 1712:    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
    #####: 1713:        out_string(c, "CLIENT_ERROR options flags too long");
    #####: 1714:        return;
        -: 1715:    }
        -: 1716:
        -: 1717:    // scrubs duplicated options and sets flags for how to load the item.
        -: 1718:    // we pass in the first token that should be a flag.
       15: 1719:    if (_meta_flag_preparse(tokens, 2, &of, &errstr) != 0) {
    #####: 1720:        out_errstring(c, "CLIENT_ERROR invalid or duplicate flag");
    #####: 1721:        return;
        -: 1722:    }
       15: 1723:    assert(c != NULL);
       15: 1724:    c->noreply = of.no_reply;
        -: 1725:
       15: 1726:    key = tokens[KEY_TOKEN].value;
       15: 1727:    nkey = tokens[KEY_TOKEN].length;
        -: 1728:
        -: 1729:    // "mode switch" to alternative commands
       15: 1730:    switch (of.mode) {
        -: 1731:        case 0: // no switch supplied.
        -: 1732:            break;
        -: 1733:        case 'I': // Incr (default)
        -: 1734:        case '+':
        -: 1735:            incr = true;
        -: 1736:            break;
        2: 1737:        case 'D': // Decr.
        -: 1738:        case '-':
        2: 1739:            incr = false;
        2: 1740:            break;
    #####: 1741:        default:
    #####: 1742:            errstr = "CLIENT_ERROR invalid mode for ma M token";
    #####: 1743:            goto error;
       15: 1744:            break;
        -: 1745:    }
        -: 1746:
        -: 1747:    // take hash value and manually lock item... hold lock during store phase
        -: 1748:    // on miss and avoid recalculating the hash multiple times.
       15: 1749:    hv = hash(key, nkey);
       15: 1750:    item_lock(hv);
       15: 1751:    locked = true;
       15: 1752:    char tmpbuf[INCR_MAX_STORAGE_LEN];
        -: 1753:
        -: 1754:    // return a referenced item if it exists, so we can modify it here, rather
        -: 1755:    // than adding even more parameters to do_add_delta.
       15: 1756:    bool item_created = false;
       15: 1757:    switch(do_add_delta(c, key, nkey, incr, of.delta, tmpbuf, &of.req_cas_id, hv, &it)) {
        -: 1758:    case DIV_BY_ZERO:
        -: 1759:        break;
        8: 1760:    case OK:
        8: 1761:        if (c->noreply)
        1: 1762:            resp->skip = true;
        8: 1763:        if (settings.meta_response_old) {
    #####: 1764:            memcpy(resp->wbuf, "OK ", 3);
        -: 1765:        } else {
        8: 1766:            memcpy(resp->wbuf, "HD ", 3);
        -: 1767:        }
        -: 1768:        break;
        1: 1769:    case NON_NUMERIC:
        1: 1770:        errstr = "CLIENT_ERROR cannot increment or decrement non-numeric value";
        1: 1771:        goto error;
    #####: 1772:        break;
    #####: 1773:    case EOM:
    #####: 1774:        errstr = "SERVER_ERROR out of memory";
    #####: 1775:        goto error;
        5: 1776:        break;
        5: 1777:    case DELTA_ITEM_NOT_FOUND:
        5: 1778:        if (of.vivify) {
        3: 1779:            itoa_u64(of.initial, tmpbuf);
        3: 1780:            int vlen = strlen(tmpbuf);
        -: 1781:
        3: 1782:            it = item_alloc(key, nkey, 0, 0, vlen+2);
        3: 1783:            if (it != NULL) {
        3: 1784:                memcpy(ITEM_data(it), tmpbuf, vlen);
        3: 1785:                memcpy(ITEM_data(it) + vlen, "\r\n", 2);
        3: 1786:                if (do_store_item(it, NREAD_ADD, c, hv)) {
        -: 1787:                    item_created = true;
        -: 1788:                } else {
        -: 1789:                    // Not sure how we can get here if we're holding the lock.
    #####: 1790:                    memcpy(resp->wbuf, "NS ", 3);
        -: 1791:                }
        -: 1792:            } else {
    #####: 1793:                errstr = "SERVER_ERROR Out of memory allocating new item";
    #####: 1794:                goto error;
        -: 1795:            }
        -: 1796:        } else {
        2: 1797:            pthread_mutex_lock(&c->thread->stats.mutex);
        2: 1798:            if (incr) {
        2: 1799:                c->thread->stats.incr_misses++;
        -: 1800:            } else {
    #####: 1801:                c->thread->stats.decr_misses++;
        -: 1802:            }
        2: 1803:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1804:            // won't have a valid it here.
        2: 1805:            memcpy(p, "NF ", 3);
        2: 1806:            p += 3;
        -: 1807:        }
        -: 1808:        break;
        -: 1809:    case DELTA_ITEM_CAS_MISMATCH:
        -: 1810:        // also returns without a valid it.
        1: 1811:        memcpy(p, "EX ", 3);
        1: 1812:        p += 3;
        1: 1813:        break;
        -: 1814:    }
        -: 1815:
        -: 1816:    // final loop
        -: 1817:    // allows building the response with information after vivifying from a
        -: 1818:    // miss, or returning a new CAS value after add_delta().
       14: 1819:    if (it) {
       11: 1820:        size_t vlen = strlen(tmpbuf);
       11: 1821:        if (of.value) {
        8: 1822:            memcpy(p, "VA ", 3);
        8: 1823:            p = itoa_u32(vlen, p+3);
        -: 1824:        } else {
        3: 1825:            if (settings.meta_response_old) {
    #####: 1826:                memcpy(p, "OK", 2);
        -: 1827:            } else {
        3: 1828:                memcpy(p, "HD", 2);
        -: 1829:            }
        3: 1830:            p += 2;
        -: 1831:        }
        -: 1832:
       49: 1833:        for (i = KEY_TOKEN+1; i < ntokens-1; i++) {
       38: 1834:            switch (tokens[i].value[0]) {
        2: 1835:                case 'c':
        2: 1836:                    META_CHAR(p, 'c');
        2: 1837:                    p = itoa_u64(ITEM_get_cas(it), p);
        2: 1838:                    break;
        6: 1839:                case 't':
        6: 1840:                    META_CHAR(p, 't');
        6: 1841:                    if (it->exptime == 0) {
        5: 1842:                        *p = '-';
        5: 1843:                        *(p+1) = '1';
        5: 1844:                        p += 2;
        -: 1845:                    } else {
        1: 1846:                        p = itoa_u32(it->exptime - current_time, p);
        -: 1847:                    }
        -: 1848:                    break;
        1: 1849:                case 'T':
        1: 1850:                    it->exptime = of.exptime;
        1: 1851:                    break;
        8: 1852:                case 'N':
        8: 1853:                    if (item_created) {
        3: 1854:                        it->exptime = of.autoviv_exptime;
        -: 1855:                    }
        -: 1856:                    break;
        -: 1857:                // TODO: macro perhaps?
    #####: 1858:                case 'O':
    #####: 1859:                    if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {
    #####: 1860:                        errstr = "CLIENT_ERROR opaque token too long";
    #####: 1861:                        goto error;
        -: 1862:                    }
    #####: 1863:                    META_SPACE(p);
    #####: 1864:                    memcpy(p, tokens[i].value, tokens[i].length);
    #####: 1865:                    p += tokens[i].length;
    #####: 1866:                    break;
    #####: 1867:                case 'k':
    #####: 1868:                    META_KEY(p, key, nkey, of.key_binary);
        -: 1869:                    break;
        -: 1870:            }
        -: 1871:        }
        -: 1872:
       11: 1873:        if (of.value) {
        8: 1874:            *p = '\r';
        8: 1875:            *(p+1) = '\n';
        8: 1876:            p += 2;
        8: 1877:            memcpy(p, tmpbuf, vlen);
        8: 1878:            p += vlen;
        -: 1879:        }
        -: 1880:
       11: 1881:        do_item_remove(it);
        -: 1882:    } else {
        -: 1883:        // No item to handle. still need to return opaque/key tokens
        7: 1884:        for (i = KEY_TOKEN+1; i < ntokens-1; i++) {
        4: 1885:            switch (tokens[i].value[0]) {
        -: 1886:                // TODO: macro perhaps?
    #####: 1887:                case 'O':
    #####: 1888:                    if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {
    #####: 1889:                        errstr = "CLIENT_ERROR opaque token too long";
    #####: 1890:                        goto error;
        -: 1891:                    }
    #####: 1892:                    META_SPACE(p);
    #####: 1893:                    memcpy(p, tokens[i].value, tokens[i].length);
    #####: 1894:                    p += tokens[i].length;
    #####: 1895:                    break;
    #####: 1896:                case 'k':
    #####: 1897:                    META_KEY(p, key, nkey, of.key_binary);
        -: 1898:                    break;
        -: 1899:            }
        -: 1900:        }
        -: 1901:    }
        -: 1902:
       14: 1903:    item_unlock(hv);
        -: 1904:
       14: 1905:    resp->wbytes = p - resp->wbuf;
       14: 1906:    memcpy(resp->wbuf + resp->wbytes, "\r\n", 2);
       14: 1907:    resp->wbytes += 2;
       14: 1908:    resp_add_iov(resp, resp->wbuf, resp->wbytes);
       14: 1909:    conn_set_state(c, conn_new_cmd);
       14: 1910:    return;
        1: 1911:error:
        1: 1912:    if (it != NULL)
    #####: 1913:        do_item_remove(it);
        1: 1914:    if (locked)
        1: 1915:        item_unlock(hv);
        1: 1916:    out_errstring(c, errstr);
        -: 1917:}
        -: 1918:
        -: 1919:
   301542: 1920:static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
   301542: 1921:    char *key;
   301542: 1922:    size_t nkey;
   301542: 1923:    unsigned int flags;
   301542: 1924:    int32_t exptime_int = 0;
   301542: 1925:    rel_time_t exptime = 0;
   301542: 1926:    int vlen;
   301542: 1927:    uint64_t req_cas_id=0;
   301542: 1928:    item *it;
        -: 1929:
  301542*: 1930:    assert(c != NULL);
        -: 1931:
   301542: 1932:    set_noreply_maybe(c, tokens, ntokens);
        -: 1933:
   301542: 1934:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 1935:        out_string(c, "CLIENT_ERROR bad command line format");
      16*: 1936:        return;
        -: 1937:    }
        -: 1938:
   301542: 1939:    key = tokens[KEY_TOKEN].value;
   301542: 1940:    nkey = tokens[KEY_TOKEN].length;
        -: 1941:
   603082: 1942:    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)
   301541: 1943:           && safe_strtol(tokens[3].value, &exptime_int)
   301540: 1944:           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {
        3: 1945:        out_string(c, "CLIENT_ERROR bad command line format");
        3: 1946:        return;
        -: 1947:    }
        -: 1948:
   603077: 1949:    exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));
        -: 1950:
        -: 1951:    // does cas value exist?
   301539: 1952:    if (handle_cas) {
       13: 1953:        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {
        1: 1954:            out_string(c, "CLIENT_ERROR bad command line format");
        1: 1955:            return;
        -: 1956:        }
        -: 1957:    }
        -: 1958:
   301538: 1959:    if (vlen < 0 || vlen > (INT_MAX - 2)) {
        3: 1960:        out_string(c, "CLIENT_ERROR bad command line format");
        3: 1961:        return;
        -: 1962:    }
   301535: 1963:    vlen += 2;
        -: 1964:
   301535: 1965:    if (settings.detail_enabled) {
      101: 1966:        stats_prefix_record_set(key, nkey);
        -: 1967:    }
        -: 1968:
   301535: 1969:    it = item_alloc(key, nkey, flags, exptime, vlen);
        -: 1970:
   301535: 1971:    if (it == 0) {
        9: 1972:        enum store_item_type status;
        9: 1973:        if (! item_size_ok(nkey, flags, vlen)) {
        4: 1974:            out_string(c, "SERVER_ERROR object too large for cache");
        4: 1975:            status = TOO_LARGE;
        4: 1976:            pthread_mutex_lock(&c->thread->stats.mutex);
        4: 1977:            c->thread->stats.store_too_large++;
        4: 1978:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1979:        } else {
        5: 1980:            out_of_memory(c, "SERVER_ERROR out of memory storing object");
        5: 1981:            status = NO_MEMORY;
        5: 1982:            pthread_mutex_lock(&c->thread->stats.mutex);
        5: 1983:            c->thread->stats.store_no_memory++;
        5: 1984:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1985:        }
       9*: 1986:        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
        -: 1987:                NULL, status, comm, key, nkey, 0, 0, c->sfd);
        -: 1988:        /* swallow the data line */
        9: 1989:        conn_set_state(c, conn_swallow);
        9: 1990:        c->sbytes = vlen;
        -: 1991:
        -: 1992:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 1993:         * Unacceptable for SET. Anywhere else too? */
        9: 1994:        if (comm == NREAD_SET) {
        9: 1995:            it = item_get(key, nkey, c, DONT_UPDATE);
        9: 1996:            if (it) {
        2: 1997:                item_unlink(it);
        2: 1998:                STORAGE_delete(c->thread->storage, it);
        2: 1999:                item_remove(it);
        -: 2000:            }
        -: 2001:        }
        -: 2002:
        9: 2003:        return;
        -: 2004:    }
   301526: 2005:    ITEM_set_cas(it, req_cas_id);
        -: 2006:
   301526: 2007:    c->item = it;
        -: 2008:#ifdef NEED_ALIGN
        -: 2009:    if (it->it_flags & ITEM_CHUNKED) {
        -: 2010:        c->ritem = ITEM_schunk(it);
        -: 2011:    } else {
        -: 2012:        c->ritem = ITEM_data(it);
        -: 2013:    }
        -: 2014:#else
   301526: 2015:    c->ritem = ITEM_data(it);
        -: 2016:#endif
   301526: 2017:    c->rlbytes = it->nbytes;
   301526: 2018:    c->cmd = comm;
   301526: 2019:    conn_set_state(c, conn_nread);
        -: 2020:}
        -: 2021:
     2004: 2022:static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
     2004: 2023:    char *key;
     2004: 2024:    size_t nkey;
     2004: 2025:    int32_t exptime_int = 0;
     2004: 2026:    rel_time_t exptime = 0;
     2004: 2027:    item *it;
        -: 2028:
    2004*: 2029:    assert(c != NULL);
        -: 2030:
     2004: 2031:    set_noreply_maybe(c, tokens, ntokens);
        -: 2032:
     2004: 2033:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 2034:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 2035:        return;
        -: 2036:    }
        -: 2037:
     2004: 2038:    key = tokens[KEY_TOKEN].value;
     2004: 2039:    nkey = tokens[KEY_TOKEN].length;
        -: 2040:
     2004: 2041:    if (!safe_strtol(tokens[2].value, &exptime_int)) {
    #####: 2042:        out_string(c, "CLIENT_ERROR invalid exptime argument");
    #####: 2043:        return;
        -: 2044:    }
        -: 2045:
     4007: 2046:    exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));
     2004: 2047:    it = item_touch(key, nkey, exptime, c);
     2004: 2048:    if (it) {
     2004: 2049:        pthread_mutex_lock(&c->thread->stats.mutex);
     2004: 2050:        c->thread->stats.touch_cmds++;
     2004: 2051:        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
     2004: 2052:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2053:
     2004: 2054:        out_string(c, "TOUCHED");
     2004: 2055:        item_remove(it);
        -: 2056:    } else {
    #####: 2057:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2058:        c->thread->stats.touch_cmds++;
    #####: 2059:        c->thread->stats.touch_misses++;
    #####: 2060:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2061:
    #####: 2062:        out_string(c, "NOT_FOUND");
        -: 2063:    }
        -: 2064:}
        -: 2065:
        -: 2066:/* MULTIPLY AND DIVIDE */
    #####: 2067:static void process_mult_command(conn *c, token_t *tokens, const size_t ntokens, const bool mult) {
    #####: 2068:    char temp[INCR_MAX_STORAGE_LEN];
    #####: 2069:    uint64_t delta;
    #####: 2070:    char *key;
    #####: 2071:    size_t nkey;
        -: 2072:
    #####: 2073:    assert(c != NULL);
        -: 2074:
    #####: 2075:    set_noreply_maybe(c, tokens, ntokens);
        -: 2076:
    #####: 2077:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 2078:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 2079:        return;
        -: 2080:    }
        -: 2081:
    #####: 2082:    key = tokens[KEY_TOKEN].value;
    #####: 2083:    nkey = tokens[KEY_TOKEN].length;
        -: 2084:
    #####: 2085:    if (!safe_strtoull(tokens[2].value, &delta)) {
    #####: 2086:        out_string(c, "CLIENT_ERROR invalid numeric delta argument");
    #####: 2087:        return;
        -: 2088:    }
        -: 2089:
    #####: 2090:    switch(mult_delta(c, key, nkey, mult, delta, temp, NULL)) {
    #####: 2091:    case DIV_BY_ZERO:
    #####: 2092:        out_string(c, "CLIENT_ERROR cannot divide by zero");
    #####: 2093:        break;
    #####: 2094:    case OK:
    #####: 2095:        out_string(c, temp);
    #####: 2096:        break;
    #####: 2097:    case NON_NUMERIC:
    #####: 2098:        out_string(c, "CLIENT_ERROR cannot increment or decrement non-numeric value");
    #####: 2099:        break;
    #####: 2100:    case EOM:
    #####: 2101:        out_of_memory(c, "SERVER_ERROR out of memory");
    #####: 2102:        break;
    #####: 2103:    case DELTA_ITEM_NOT_FOUND:
    #####: 2104:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2105:        if (mult) {
    #####: 2106:            c->thread->stats.incr_misses++;
        -: 2107:        } else {
    #####: 2108:            c->thread->stats.decr_misses++;
        -: 2109:        }
    #####: 2110:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2111:
    #####: 2112:        out_string(c, "NOT_FOUND");
    #####: 2113:        break;
        -: 2114:    case DELTA_ITEM_CAS_MISMATCH:
        -: 2115:        break; /* Should never get here */
        -: 2116:    }
        -: 2117:}
        -: 2118:
      273: 2119:static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
      273: 2120:    char temp[INCR_MAX_STORAGE_LEN];
      273: 2121:    uint64_t delta;
      273: 2122:    char *key;
      273: 2123:    size_t nkey;
        -: 2124:
     273*: 2125:    assert(c != NULL);
        -: 2126:
      273: 2127:    set_noreply_maybe(c, tokens, ntokens);
        -: 2128:
      273: 2129:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 2130:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 2131:        return;
        -: 2132:    }
        -: 2133:
      273: 2134:    key = tokens[KEY_TOKEN].value;
      273: 2135:    nkey = tokens[KEY_TOKEN].length;
        -: 2136:
      273: 2137:    if (!safe_strtoull(tokens[2].value, &delta)) {
    #####: 2138:        out_string(c, "CLIENT_ERROR invalid numeric delta argument");
    #####: 2139:        return;
        -: 2140:    }
        -: 2141:
      273: 2142:    switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {
        -: 2143:    case DIV_BY_ZERO:
        -: 2144:        break;
      267: 2145:    case OK:
      267: 2146:        out_string(c, temp);
      267: 2147:        break;
        2: 2148:    case NON_NUMERIC:
        2: 2149:        out_string(c, "CLIENT_ERROR cannot increment or decrement non-numeric value");
        2: 2150:        break;
    #####: 2151:    case EOM:
    #####: 2152:        out_of_memory(c, "SERVER_ERROR out of memory");
    #####: 2153:        break;
        4: 2154:    case DELTA_ITEM_NOT_FOUND:
        4: 2155:        pthread_mutex_lock(&c->thread->stats.mutex);
        4: 2156:        if (incr) {
        1: 2157:            c->thread->stats.incr_misses++;
        -: 2158:        } else {
        3: 2159:            c->thread->stats.decr_misses++;
        -: 2160:        }
        4: 2161:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2162:
        4: 2163:        out_string(c, "NOT_FOUND");
        4: 2164:        break;
        -: 2165:    case DELTA_ITEM_CAS_MISMATCH:
        -: 2166:        break; /* Should never get here */
        -: 2167:    }
        -: 2168:}
        -: 2169:
        -: 2170:
   141090: 2171:static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
   141090: 2172:    char *key;
   141090: 2173:    size_t nkey;
   141090: 2174:    item *it;
   141090: 2175:    uint32_t hv;
        -: 2176:
  141090*: 2177:    assert(c != NULL);
        -: 2178:
   141090: 2179:    if (ntokens > 3) {
     9852: 2180:        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, "0") == 0;
     9852: 2181:        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
     9850: 2182:        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
     9853: 2183:            || (ntokens == 5 && hold_is_zero && sets_noreply);
     9852: 2184:        if (!valid) {
        2: 2185:            out_string(c, "CLIENT_ERROR bad command line format.  "
        -: 2186:                       "Usage: delete <key> [noreply]");
        4: 2187:            return;
        -: 2188:        }
        -: 2189:    }
        -: 2190:
        -: 2191:
   141088: 2192:    key = tokens[KEY_TOKEN].value;
   141088: 2193:    nkey = tokens[KEY_TOKEN].length;
        -: 2194:
   141088: 2195:    if(nkey > KEY_MAX_LENGTH) {
    #####: 2196:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 2197:        return;
        -: 2198:    }
        -: 2199:
   141088: 2200:    if (settings.detail_enabled) {
        1: 2201:        stats_prefix_record_delete(key, nkey);
        -: 2202:    }
        -: 2203:
   141088: 2204:    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
   141088: 2205:    if (it) {
   141080: 2206:        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
        -: 2207:
   141080: 2208:        pthread_mutex_lock(&c->thread->stats.mutex);
   141080: 2209:        c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
   141080: 2210:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2211:
   141080: 2212:        do_item_unlink(it, hv);
   141080: 2213:        STORAGE_delete(c->thread->storage, it);
   141080: 2214:        do_item_remove(it);      /* release our reference */
   141080: 2215:        out_string(c, "DELETED");
        -: 2216:    } else {
        8: 2217:        pthread_mutex_lock(&c->thread->stats.mutex);
        8: 2218:        c->thread->stats.delete_misses++;
        8: 2219:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2220:
        8: 2221:        out_string(c, "NOT_FOUND");
        -: 2222:    }
   141088: 2223:    item_unlock(hv);
        -: 2224:}
        -: 2225:
        2: 2226:static void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {
        2: 2227:    unsigned int level;
        -: 2228:
       2*: 2229:    assert(c != NULL);
        -: 2230:
        2: 2231:    set_noreply_maybe(c, tokens, ntokens);
        -: 2232:
        2: 2233:    if (!safe_strtoul(tokens[1].value, (uint32_t*)&level)) {
        1: 2234:        out_string(c, "CLIENT_ERROR bad command line format");
        1: 2235:        return;
        -: 2236:    }
        1: 2237:    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;
        1: 2238:    out_string(c, "OK");
        1: 2239:    return;
        -: 2240:}
        -: 2241:
        -: 2242:#ifdef MEMCACHED_DEBUG
    #####: 2243:static void process_misbehave_command(conn *c) {
    #####: 2244:    int allowed = 0;
        -: 2245:
        -: 2246:    // try opening new TCP socket
    #####: 2247:    int i = socket(AF_INET, SOCK_STREAM, 0);
    #####: 2248:    if (i != -1) {
    #####: 2249:        allowed++;
    #####: 2250:        close(i);
        -: 2251:    }
        -: 2252:
        -: 2253:    // try executing new commands
    #####: 2254:    i = system("sleep 0");
    #####: 2255:    if (i != -1) {
    #####: 2256:        allowed++;
        -: 2257:    }
        -: 2258:
    #####: 2259:    if (allowed) {
    #####: 2260:        out_string(c, "ERROR");
        -: 2261:    } else {
    #####: 2262:        out_string(c, "OK");
        -: 2263:    }
    #####: 2264:}
        -: 2265:
        5: 2266:static void process_debugtime_command(conn *c, token_t *tokens, const size_t ntokens) {
        5: 2267:    if (strcmp(tokens[1].value, "p") == 0) {
    #####: 2268:        if (!is_paused) {
    #####: 2269:            is_paused = true;
        -: 2270:        }
        5: 2271:    } else if (strcmp(tokens[1].value, "r") == 0) {
    #####: 2272:        if (is_paused) {
    #####: 2273:            is_paused = false;
        -: 2274:        }
        -: 2275:    } else {
        5: 2276:        int64_t time_delta = 0;
        5: 2277:        if (!safe_strtoll(tokens[1].value, &time_delta)) {
    #####: 2278:            out_string(c, "ERROR");
    #####: 2279:            return;
        -: 2280:        }
        5: 2281:        delta += time_delta;
        5: 2282:        current_time += delta;
        -: 2283:    }
        5: 2284:    out_string(c, "OK");
        -: 2285:}
        -: 2286:#endif
        -: 2287:
        2: 2288:static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {
        2: 2289:    unsigned int level;
        2: 2290:    double ratio;
        -: 2291:
       2*: 2292:    assert(c != NULL);
        -: 2293:
        2: 2294:    set_noreply_maybe(c, tokens, ntokens);
        -: 2295:
        2: 2296:    if (strcmp(tokens[2].value, "ratio") == 0) {
    #####: 2297:        if (ntokens < 5 || !safe_strtod(tokens[3].value, &ratio)) {
    #####: 2298:            out_string(c, "ERROR");
    #####: 2299:            return;
        -: 2300:        }
    #####: 2301:        settings.slab_automove_ratio = ratio;
        -: 2302:    } else {
        2: 2303:        if (!safe_strtoul(tokens[2].value, (uint32_t*)&level)) {
        1: 2304:            out_string(c, "CLIENT_ERROR bad command line format");
        1: 2305:            return;
        -: 2306:        }
        1: 2307:        if (level == 0) {
        1: 2308:            settings.slab_automove = 0;
    #####: 2309:        } else if (level == 1 || level == 2) {
    #####: 2310:            settings.slab_automove = level;
        -: 2311:        } else {
    #####: 2312:            out_string(c, "ERROR");
    #####: 2313:            return;
        -: 2314:        }
        -: 2315:    }
        1: 2316:    out_string(c, "OK");
        1: 2317:    return;
        -: 2318:}
        -: 2319:
        -: 2320:/* TODO: decide on syntax for sampling? */
       11: 2321:static void process_watch_command(conn *c, token_t *tokens, const size_t ntokens) {
       11: 2322:    uint16_t f = 0;
       11: 2323:    int x;
      11*: 2324:    assert(c != NULL);
        -: 2325:
       11: 2326:    set_noreply_maybe(c, tokens, ntokens);
       11: 2327:    if (!settings.watch_enabled) {
        1: 2328:        out_string(c, "CLIENT_ERROR watch commands not allowed");
        1: 2329:        return;
        -: 2330:    }
        -: 2331:
       10: 2332:    if (resp_has_stack(c)) {
    #####: 2333:        out_string(c, "ERROR cannot pipeline other commands before watch");
    #####: 2334:        return;
        -: 2335:    }
        -: 2336:
       10: 2337:    if (ntokens > 2) {
       22: 2338:        for (x = COMMAND_TOKEN + 1; x < ntokens - 1; x++) {
       13: 2339:            if ((strcmp(tokens[x].value, "rawcmds") == 0)) {
    #####: 2340:                f |= LOG_RAWCMDS;
       13: 2341:            } else if ((strcmp(tokens[x].value, "evictions") == 0)) {
        2: 2342:                f |= LOG_EVICTIONS;
       11: 2343:            } else if ((strcmp(tokens[x].value, "fetchers") == 0)) {
        5: 2344:                f |= LOG_FETCHERS;
        6: 2345:            } else if ((strcmp(tokens[x].value, "mutations") == 0)) {
        5: 2346:                f |= LOG_MUTATIONS;
        1: 2347:            } else if ((strcmp(tokens[x].value, "sysevents") == 0)) {
    #####: 2348:                f |= LOG_SYSEVENTS;
        1: 2349:            } else if ((strcmp(tokens[x].value, "connevents") == 0)) {
        1: 2350:                f |= LOG_CONNEVENTS;
    #####: 2351:            } else if ((strcmp(tokens[x].value, "proxyreqs") == 0)) {
    #####: 2352:                f |= LOG_PROXYREQS;
    #####: 2353:            } else if ((strcmp(tokens[x].value, "proxyevents") == 0)) {
    #####: 2354:                f |= LOG_PROXYEVENTS;
    #####: 2355:            } else if ((strcmp(tokens[x].value, "proxyuser") == 0)) {
    #####: 2356:                f |= LOG_PROXYUSER;
        -: 2357:            } else {
    #####: 2358:                out_string(c, "ERROR");
    #####: 2359:                return;
        -: 2360:            }
        -: 2361:        }
        -: 2362:    } else {
        -: 2363:        f |= LOG_FETCHERS;
        -: 2364:    }
        -: 2365:
       10: 2366:    switch(logger_add_watcher(c, c->sfd, f)) {
    #####: 2367:        case LOGGER_ADD_WATCHER_TOO_MANY:
    #####: 2368:            out_string(c, "WATCHER_TOO_MANY log watcher limit reached");
    #####: 2369:            break;
    #####: 2370:        case LOGGER_ADD_WATCHER_FAILED:
    #####: 2371:            out_string(c, "WATCHER_FAILED failed to add log watcher");
    #####: 2372:            break;
       10: 2373:        case LOGGER_ADD_WATCHER_OK:
       10: 2374:            conn_set_state(c, conn_watch);
       10: 2375:            event_del(&c->event);
       10: 2376:            break;
        -: 2377:    }
        -: 2378:}
        -: 2379:
        3: 2380:static void process_memlimit_command(conn *c, token_t *tokens, const size_t ntokens) {
        3: 2381:    uint32_t memlimit;
       3*: 2382:    assert(c != NULL);
        -: 2383:
        3: 2384:    set_noreply_maybe(c, tokens, ntokens);
        -: 2385:
        3: 2386:    if (!safe_strtoul(tokens[1].value, &memlimit)) {
    #####: 2387:        out_string(c, "ERROR");
        -: 2388:    } else {
        3: 2389:        if (memlimit < 8) {
    #####: 2390:            out_string(c, "MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m");
        -: 2391:        } else {
        3: 2392:            if (memlimit > 1000000000) {
    #####: 2393:                out_string(c, "MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes");
        3: 2394:            } else if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {
        3: 2395:                if (settings.verbose > 0) {
    #####: 2396:                    fprintf(stderr, "maxbytes adjusted to %llum\n", (unsigned long long)memlimit);
        -: 2397:                }
        -: 2398:
        3: 2399:                out_string(c, "OK");
        -: 2400:            } else {
    #####: 2401:                out_string(c, "MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust");
        -: 2402:            }
        -: 2403:        }
        -: 2404:    }
        3: 2405:}
        -: 2406:
    #####: 2407:static void process_lru_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 2408:    uint32_t pct_hot;
    #####: 2409:    uint32_t pct_warm;
    #####: 2410:    double hot_factor;
    #####: 2411:    int32_t ttl;
    #####: 2412:    double factor;
        -: 2413:
    #####: 2414:    set_noreply_maybe(c, tokens, ntokens);
        -: 2415:
    #####: 2416:    if (strcmp(tokens[1].value, "tune") == 0 && ntokens >= 7) {
    #####: 2417:        if (!safe_strtoul(tokens[2].value, &pct_hot) ||
    #####: 2418:            !safe_strtoul(tokens[3].value, &pct_warm) ||
    #####: 2419:            !safe_strtod(tokens[4].value, &hot_factor) ||
    #####: 2420:            !safe_strtod(tokens[5].value, &factor)) {
    #####: 2421:            out_string(c, "ERROR");
        -: 2422:        } else {
    #####: 2423:            if (pct_hot + pct_warm > 80) {
    #####: 2424:                out_string(c, "ERROR hot and warm pcts must not exceed 80");
    #####: 2425:            } else if (factor <= 0 || hot_factor <= 0) {
    #####: 2426:                out_string(c, "ERROR hot/warm age factors must be greater than 0");
        -: 2427:            } else {
    #####: 2428:                settings.hot_lru_pct = pct_hot;
    #####: 2429:                settings.warm_lru_pct = pct_warm;
    #####: 2430:                settings.hot_max_factor = hot_factor;
    #####: 2431:                settings.warm_max_factor = factor;
    #####: 2432:                out_string(c, "OK");
        -: 2433:            }
        -: 2434:        }
    #####: 2435:    } else if (strcmp(tokens[1].value, "mode") == 0 && ntokens >= 4 &&
    #####: 2436:               settings.lru_maintainer_thread) {
    #####: 2437:        if (strcmp(tokens[2].value, "flat") == 0) {
    #####: 2438:            settings.lru_segmented = false;
    #####: 2439:            out_string(c, "OK");
    #####: 2440:        } else if (strcmp(tokens[2].value, "segmented") == 0) {
    #####: 2441:            settings.lru_segmented = true;
    #####: 2442:            out_string(c, "OK");
        -: 2443:        } else {
    #####: 2444:            out_string(c, "ERROR");
        -: 2445:        }
    #####: 2446:    } else if (strcmp(tokens[1].value, "temp_ttl") == 0 && ntokens >= 4 &&
    #####: 2447:               settings.lru_maintainer_thread) {
    #####: 2448:        if (!safe_strtol(tokens[2].value, &ttl)) {
    #####: 2449:            out_string(c, "ERROR");
        -: 2450:        } else {
    #####: 2451:            if (ttl < 0) {
    #####: 2452:                settings.temp_lru = false;
        -: 2453:            } else {
    #####: 2454:                settings.temp_lru = true;
    #####: 2455:                settings.temporary_ttl = ttl;
        -: 2456:            }
    #####: 2457:            out_string(c, "OK");
        -: 2458:        }
        -: 2459:    } else {
    #####: 2460:        out_string(c, "ERROR");
        -: 2461:    }
    #####: 2462:}
        -: 2463:#ifdef EXTSTORE
       11: 2464:static void process_extstore_command(conn *c, token_t *tokens, const size_t ntokens) {
       11: 2465:    set_noreply_maybe(c, tokens, ntokens);
       11: 2466:    bool ok = true;
       11: 2467:    if (ntokens < 4) {
        -: 2468:        ok = false;
      11*: 2469:    } else if (strcmp(tokens[1].value, "free_memchunks") == 0 && ntokens > 4) {
        -: 2470:        // setting is deprecated and ignored, but accepted for backcompat
    #####: 2471:        unsigned int clsid = 0;
    #####: 2472:        unsigned int limit = 0;
    #####: 2473:        if (!safe_strtoul(tokens[2].value, &clsid) ||
    #####: 2474:                !safe_strtoul(tokens[3].value, &limit)) {
    #####: 2475:            ok = false;
        -: 2476:        } else {
    #####: 2477:            if (clsid < MAX_NUMBER_OF_SLAB_CLASSES) {
        -: 2478:                ok = true;
        -: 2479:            } else {
    #####: 2480:                ok = false;
        -: 2481:            }
        -: 2482:        }
       11: 2483:    } else if (strcmp(tokens[1].value, "item_size") == 0) {
    #####: 2484:        if (!safe_strtoul(tokens[2].value, &settings.ext_item_size))
        -: 2485:            ok = false;
       11: 2486:    } else if (strcmp(tokens[1].value, "item_age") == 0) {
    #####: 2487:        if (!safe_strtoul(tokens[2].value, &settings.ext_item_age))
        -: 2488:            ok = false;
       11: 2489:    } else if (strcmp(tokens[1].value, "low_ttl") == 0) {
    #####: 2490:        if (!safe_strtoul(tokens[2].value, &settings.ext_low_ttl))
        -: 2491:            ok = false;
       11: 2492:    } else if (strcmp(tokens[1].value, "recache_rate") == 0) {
        2: 2493:        if (!safe_strtoul(tokens[2].value, &settings.ext_recache_rate))
        -: 2494:            ok = false;
        9: 2495:    } else if (strcmp(tokens[1].value, "compact_under") == 0) {
        3: 2496:        if (!safe_strtoul(tokens[2].value, &settings.ext_compact_under))
        -: 2497:            ok = false;
        6: 2498:    } else if (strcmp(tokens[1].value, "drop_under") == 0) {
        2: 2499:        if (!safe_strtoul(tokens[2].value, &settings.ext_drop_under))
        -: 2500:            ok = false;
        4: 2501:    } else if (strcmp(tokens[1].value, "max_sleep") == 0) {
    #####: 2502:        if (!safe_strtoul(tokens[2].value, &settings.ext_max_sleep))
        -: 2503:            ok = false;
        4: 2504:    } else if (strcmp(tokens[1].value, "max_frag") == 0) {
        2: 2505:        if (!safe_strtod(tokens[2].value, &settings.ext_max_frag))
        -: 2506:            ok = false;
        2: 2507:    } else if (strcmp(tokens[1].value, "drop_unread") == 0) {
        2: 2508:        unsigned int v;
        2: 2509:        if (!safe_strtoul(tokens[2].value, &v)) {
        -: 2510:            ok = false;
        -: 2511:        } else {
        2: 2512:            settings.ext_drop_unread = v == 0 ? false : true;
        -: 2513:        }
        -: 2514:    } else {
        -: 2515:        ok = false;
        -: 2516:    }
       2*: 2517:    if (!ok) {
    #####: 2518:        out_string(c, "ERROR");
        -: 2519:    } else {
       11: 2520:        out_string(c, "OK");
        -: 2521:    }
       11: 2522:}
        -: 2523:#endif
       12: 2524:static void process_flush_all_command(conn *c, token_t *tokens, const size_t ntokens) {
       12: 2525:    int32_t exptime = 0;
       12: 2526:    rel_time_t new_oldest = 0;
        -: 2527:
       12: 2528:    set_noreply_maybe(c, tokens, ntokens);
        -: 2529:
       12: 2530:    pthread_mutex_lock(&c->thread->stats.mutex);
       12: 2531:    c->thread->stats.flush_cmds++;
       12: 2532:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2533:
       12: 2534:    if (!settings.flush_enabled) {
        -: 2535:        // flush_all is not allowed but we log it on stats
        1: 2536:        out_string(c, "CLIENT_ERROR flush_all not allowed");
        3: 2537:        return;
        -: 2538:    }
        -: 2539:
       20: 2540:    if (ntokens != (c->noreply ? 3 : 2)) {
        6: 2541:        if (!safe_strtol(tokens[1].value, &exptime)) {
        1: 2542:            out_string(c, "CLIENT_ERROR invalid exptime argument");
        1: 2543:            return;
        -: 2544:        }
        -: 2545:    }
        -: 2546:
        -: 2547:    /*
        -: 2548:      If exptime is zero realtime() would return zero too, and
        -: 2549:      realtime(exptime) - 1 would overflow to the max unsigned
        -: 2550:      value.  So we process exptime == 0 the same way we do when
        -: 2551:      no delay is given at all.
        -: 2552:    */
       10: 2553:    if (exptime > 0) {
        2: 2554:        new_oldest = realtime(exptime);
        -: 2555:    } else { /* exptime == 0 */
        8: 2556:        new_oldest = current_time;
        -: 2557:    }
        -: 2558:
       10: 2559:    if (settings.use_cas) {
        9: 2560:        settings.oldest_live = new_oldest - 1;
        9: 2561:        if (settings.oldest_live <= current_time)
        7: 2562:            settings.oldest_cas = get_cas_id();
        -: 2563:    } else {
        1: 2564:        settings.oldest_live = new_oldest;
        -: 2565:    }
       10: 2566:    out_string(c, "OK");
        -: 2567:}
        -: 2568:
        6: 2569:static void process_version_command(conn *c) {
        6: 2570:    out_string(c, "VERSION " VERSION);
        6: 2571:}
        -: 2572:
        3: 2573:static void process_quit_command(conn *c) {
        3: 2574:    conn_set_state(c, conn_mwrite);
        3: 2575:    c->close_after_write = true;
        3: 2576:    c->close_reason = NORMAL_CLOSE;
        3: 2577:}
        -: 2578:
        5: 2579:static void process_shutdown_command(conn *c, token_t *tokens, const size_t ntokens) {
        5: 2580:    if (!settings.shutdown_command) {
        1: 2581:        out_string(c, "ERROR: shutdown not enabled");
        1: 2582:        return;
        -: 2583:    }
        -: 2584:
        4: 2585:    if (ntokens == 2) {
        2: 2586:        c->close_reason = SHUTDOWN_CLOSE;
        2: 2587:        conn_set_state(c, conn_closing);
        2: 2588:        raise(SIGINT);
        2: 2589:    } else if (ntokens == 3 && strcmp(tokens[SUBCOMMAND_TOKEN].value, "graceful") == 0) {
        1: 2590:        c->close_reason = SHUTDOWN_CLOSE;
        1: 2591:        conn_set_state(c, conn_closing);
        1: 2592:        raise(SIGUSR1);
        -: 2593:    } else {
        1: 2594:        out_string(c, "CLIENT_ERROR invalid shutdown mode");
        -: 2595:    }
        -: 2596:}
        -: 2597:
       71: 2598:static void process_slabs_command(conn *c, token_t *tokens, const size_t ntokens) {
       71: 2599:    if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, "reassign") == 0) {
       69: 2600:        int src, dst, rv;
        -: 2601:
       69: 2602:        if (settings.slab_reassign == false) {
    #####: 2603:            out_string(c, "CLIENT_ERROR slab reassignment disabled");
    #####: 2604:            return;
        -: 2605:        }
        -: 2606:
      137: 2607:        if (! (safe_strtol(tokens[2].value, (int32_t*)&src)
       68: 2608:               && safe_strtol(tokens[3].value, (int32_t*)&dst))) {
        1: 2609:            out_string(c, "CLIENT_ERROR bad command line format");
        1: 2610:            return;
        -: 2611:        }
        -: 2612:
       68: 2613:        rv = slabs_reassign(src, dst);
       68: 2614:        switch (rv) {
       66: 2615:        case REASSIGN_OK:
       66: 2616:            out_string(c, "OK");
       66: 2617:            break;
    #####: 2618:        case REASSIGN_RUNNING:
    #####: 2619:            out_string(c, "BUSY currently processing reassign request");
    #####: 2620:            break;
    #####: 2621:        case REASSIGN_BADCLASS:
    #####: 2622:            out_string(c, "BADCLASS invalid src or dst class id");
    #####: 2623:            break;
        2: 2624:        case REASSIGN_NOSPARE:
        2: 2625:            out_string(c, "NOSPARE source class has no spare pages");
        2: 2626:            break;
    #####: 2627:        case REASSIGN_SRC_DST_SAME:
    #####: 2628:            out_string(c, "SAME src and dst class are identical");
    #####: 2629:            break;
        -: 2630:        }
       68: 2631:        return;
        2: 2632:    } else if (ntokens >= 4 &&
        2: 2633:        (strcmp(tokens[COMMAND_TOKEN + 1].value, "automove") == 0)) {
        2: 2634:        process_slabs_automove_command(c, tokens, ntokens);
        -: 2635:    } else {
    #####: 2636:        out_string(c, "ERROR");
        -: 2637:    }
        -: 2638:}
        -: 2639:
        9: 2640:static void process_lru_crawler_command(conn *c, token_t *tokens, const size_t ntokens) {
        9: 2641:    if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "crawl") == 0) {
        4: 2642:        int rv;
        4: 2643:        if (settings.lru_crawler == false) {
    #####: 2644:            out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 2645:            return;
        -: 2646:        }
        -: 2647:
        4: 2648:        rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0,
        -: 2649:                settings.lru_crawler_tocrawl);
        4: 2650:        switch(rv) {
        4: 2651:        case CRAWLER_OK:
        4: 2652:            out_string(c, "OK");
        4: 2653:            break;
    #####: 2654:        case CRAWLER_RUNNING:
    #####: 2655:            out_string(c, "BUSY currently processing crawler request");
    #####: 2656:            break;
    #####: 2657:        case CRAWLER_BADCLASS:
    #####: 2658:            out_string(c, "BADCLASS invalid class id");
    #####: 2659:            break;
    #####: 2660:        case CRAWLER_NOTSTARTED:
    #####: 2661:            out_string(c, "NOTSTARTED no items to crawl");
    #####: 2662:            break;
    #####: 2663:        case CRAWLER_ERROR:
    #####: 2664:            out_string(c, "ERROR an unknown error happened");
    #####: 2665:            break;
        -: 2666:        }
        4: 2667:        return;
        5: 2668:    } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "metadump") == 0) {
        3: 2669:        if (settings.lru_crawler == false) {
    #####: 2670:            out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 2671:            return;
        -: 2672:        }
        3: 2673:        if (!settings.dump_enabled) {
    #####: 2674:            out_string(c, "ERROR metadump not allowed");
    #####: 2675:            return;
        -: 2676:        }
        3: 2677:        if (resp_has_stack(c)) {
        1: 2678:            out_string(c, "ERROR cannot pipeline other commands before metadump");
        1: 2679:            return;
        -: 2680:        }
        -: 2681:
        2: 2682:        int rv = lru_crawler_crawl(tokens[2].value, CRAWLER_METADUMP,
        -: 2683:                c, c->sfd, LRU_CRAWLER_CAP_REMAINING);
        2: 2684:        switch(rv) {
        2: 2685:            case CRAWLER_OK:
        -: 2686:                // TODO: documentation says this string is returned, but
        -: 2687:                // it never was before. We never switch to conn_write so
        -: 2688:                // this o_s call never worked. Need to talk to users and
        -: 2689:                // decide if removing the OK from docs is fine.
        -: 2690:                //out_string(c, "OK");
        -: 2691:                // TODO: Don't reuse conn_watch here.
        2: 2692:                conn_set_state(c, conn_watch);
        2: 2693:                event_del(&c->event);
        2: 2694:                break;
    #####: 2695:            case CRAWLER_RUNNING:
    #####: 2696:                out_string(c, "BUSY currently processing crawler request");
    #####: 2697:                break;
    #####: 2698:            case CRAWLER_BADCLASS:
    #####: 2699:                out_string(c, "BADCLASS invalid class id");
    #####: 2700:                break;
    #####: 2701:            case CRAWLER_NOTSTARTED:
    #####: 2702:                out_string(c, "NOTSTARTED no items to crawl");
    #####: 2703:                break;
    #####: 2704:            case CRAWLER_ERROR:
    #####: 2705:                out_string(c, "ERROR an unknown error happened");
    #####: 2706:                break;
        -: 2707:        }
        2: 2708:        return;
       2*: 2709:    } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "tocrawl") == 0) {
    #####: 2710:        uint32_t tocrawl;
    #####: 2711:         if (!safe_strtoul(tokens[2].value, &tocrawl)) {
    #####: 2712:            out_string(c, "CLIENT_ERROR bad command line format");
    #####: 2713:            return;
        -: 2714:        }
    #####: 2715:        settings.lru_crawler_tocrawl = tocrawl;
    #####: 2716:        out_string(c, "OK");
    #####: 2717:        return;
       2*: 2718:    } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "sleep") == 0) {
    #####: 2719:        uint32_t tosleep;
    #####: 2720:        if (!safe_strtoul(tokens[2].value, &tosleep)) {
    #####: 2721:            out_string(c, "CLIENT_ERROR bad command line format");
    #####: 2722:            return;
        -: 2723:        }
    #####: 2724:        if (tosleep > 1000000) {
    #####: 2725:            out_string(c, "CLIENT_ERROR sleep must be one second or less");
    #####: 2726:            return;
        -: 2727:        }
    #####: 2728:        settings.lru_crawler_sleep = tosleep;
    #####: 2729:        out_string(c, "OK");
    #####: 2730:        return;
        2: 2731:    } else if (ntokens == 3) {
        2: 2732:        if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "enable") == 0)) {
        1: 2733:            if (start_item_crawler_thread() == 0) {
        1: 2734:                out_string(c, "OK");
        -: 2735:            } else {
    #####: 2736:                out_string(c, "ERROR failed to start lru crawler thread");
        -: 2737:            }
        1: 2738:        } else if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "disable") == 0)) {
        1: 2739:            if (stop_item_crawler_thread(CRAWLER_NOWAIT) == 0) {
        1: 2740:                out_string(c, "OK");
        -: 2741:            } else {
    #####: 2742:                out_string(c, "ERROR failed to stop lru crawler thread");
        -: 2743:            }
        -: 2744:        } else {
    #####: 2745:            out_string(c, "ERROR");
        -: 2746:        }
        2: 2747:        return;
        -: 2748:    } else {
    #####: 2749:        out_string(c, "ERROR");
        -: 2750:    }
        -: 2751:}
        -: 2752:#ifdef TLS
        -: 2753:static void process_refresh_certs_command(conn *c, token_t *tokens, const size_t ntokens) {
        -: 2754:    set_noreply_maybe(c, tokens, ntokens);
        -: 2755:    char *errmsg = NULL;
        -: 2756:    if (refresh_certs(&errmsg)) {
        -: 2757:        out_string(c, "OK");
        -: 2758:    } else {
        -: 2759:        write_and_free(c, errmsg, strlen(errmsg));
        -: 2760:    }
        -: 2761:    return;
        -: 2762:}
        -: 2763:#endif
        -: 2764:
        -: 2765:// TODO: pipelined commands are incompatible with shifting connections to a
        -: 2766:// side thread. Given this only happens in two instances (watch and
        -: 2767:// lru_crawler metadump) it should be fine for things to bail. It _should_ be
        -: 2768:// unusual for these commands.
        -: 2769:// This is hard to fix since tokenize_command() mutilates the read buffer, so
        -: 2770:// we can't drop out and back in again.
        -: 2771:// Leaving this note here to spend more time on a fix when necessary, or if an
        -: 2772:// opportunity becomes obvious.
   559458: 2773:void process_command_ascii(conn *c, char *command) {
        -: 2774:
   559458: 2775:    token_t tokens[MAX_TOKENS];
   559458: 2776:    size_t ntokens;
   559458: 2777:    int comm;
        -: 2778:
  559458*: 2779:    assert(c != NULL);
        -: 2780:
   559458: 2781:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
        -: 2782:
   559458: 2783:    if (settings.verbose > 1)
    #####: 2784:        fprintf(stderr, "<%d %s\n", c->sfd, command);
        -: 2785:
        -: 2786:    /*
        -: 2787:     * for commands set/add/replace, we build an item and read the data
        -: 2788:     * directly into it, then continue in nread_complete().
        -: 2789:     */
        -: 2790:
        -: 2791:    // Prep the response object for this query.
   559458: 2792:    if (!resp_start(c)) {
        1: 2793:        conn_set_state(c, conn_closing);
        1: 2794:        return;
        -: 2795:    }
        -: 2796:
   559457: 2797:    ntokens = tokenize_command(command, tokens, MAX_TOKENS);
        -: 2798:    // All commands need a minimum of two tokens: cmd and NULL finalizer
        -: 2799:    // There are also no valid commands shorter than two bytes.
   559457: 2800:    if (ntokens < 2 || tokens[COMMAND_TOKEN].length < 2) {
        5: 2801:        out_string(c, "ERROR");
        5: 2802:        return;
        -: 2803:    }
        -: 2804:
        -: 2805:    // Meta commands are all 2-char in length.
   559452: 2806:    char first = tokens[COMMAND_TOKEN].value[0];
   559452: 2807:    if (first == 'm' && tokens[COMMAND_TOKEN].length == 2) {
      110: 2808:        switch (tokens[COMMAND_TOKEN].value[1]) {
       56: 2809:            case 'g':
       56: 2810:                process_mget_command(c, tokens, ntokens);
       56: 2811:                break;
       30: 2812:            case 's':
       30: 2813:                process_mset_command(c, tokens, ntokens);
       30: 2814:                break;
        4: 2815:            case 'd':
        4: 2816:                process_mdelete_command(c, tokens, ntokens);
        4: 2817:                break;
        3: 2818:            case 'n':
        3: 2819:                out_string(c, "MN");
        -: 2820:                // mn command forces immediate writeback flush.
        3: 2821:                conn_set_state(c, conn_mwrite);
        3: 2822:                break;
       15: 2823:            case 'a':
       15: 2824:                process_marithmetic_command(c, tokens, ntokens);
       15: 2825:                break;
        2: 2826:            case 'e':
        2: 2827:                process_meta_command(c, tokens, ntokens);
        2: 2828:                break;
    #####: 2829:            default:
    #####: 2830:                out_string(c, "ERROR");
    #####: 2831:                break;
        -: 2832:        }
   559342: 2833:    } else if (first == 'g') {
        -: 2834:        // Various get commands are very common.
  112690*: 2835:        WANT_TOKENS_MIN(ntokens, 3);
   112690: 2836:        if (strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) {
        -: 2837:
   112666: 2838:            process_get_command(c, tokens, ntokens, false, false);
       24: 2839:        } else if (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0) {
        -: 2840:
       18: 2841:            process_get_command(c, tokens, ntokens, true, false);
        6: 2842:        } else if (strcmp(tokens[COMMAND_TOKEN].value, "gat") == 0) {
        -: 2843:
        5: 2844:            process_get_command(c, tokens, ntokens, false, true);
        1: 2845:        } else if (strcmp(tokens[COMMAND_TOKEN].value, "gats") == 0) {
        -: 2846:
        1: 2847:            process_get_command(c, tokens, ntokens, true, true);
        -: 2848:        } else {
    #####: 2849:            out_string(c, "ERROR");
        -: 2850:        }
        -: 2851:    } else if (first == 's') {
   286553: 2852:        if (strcmp(tokens[COMMAND_TOKEN].value, "set") == 0 && (comm = NREAD_SET)) {
        -: 2853:
  284879*: 2854:            WANT_TOKENS_OR(ntokens, 6, 7);
   284879: 2855:            process_update_command(c, tokens, ntokens, comm, false);
     1674: 2856:        } else if (strcmp(tokens[COMMAND_TOKEN].value, "stats") == 0) {
        -: 2857:
     1598: 2858:            process_stat(c, tokens, ntokens);
       76: 2859:        } else if (strcmp(tokens[COMMAND_TOKEN].value, "shutdown") == 0) {
        -: 2860:
        5: 2861:            process_shutdown_command(c, tokens, ntokens);
       71: 2862:        } else if (strcmp(tokens[COMMAND_TOKEN].value, "slabs") == 0) {
        -: 2863:
       71: 2864:            process_slabs_command(c, tokens, ntokens);
        -: 2865:        } else {
    #####: 2866:            out_string(c, "ERROR");
        -: 2867:        }
        -: 2868:    } else if (first == 'a') {
     8641: 2869:        if ((strcmp(tokens[COMMAND_TOKEN].value, "add") == 0 && (comm = NREAD_ADD)) ||
     8003: 2870:            (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) ) {
        -: 2871:
    8641*: 2872:            WANT_TOKENS_OR(ntokens, 6, 7);
     8641: 2873:            process_update_command(c, tokens, ntokens, comm, false);
        -: 2874:        } else {
    #####: 2875:            out_string(c, "ERROR");
        -: 2876:        }
        -: 2877:    } else if (first == 'c') {
       20: 2878:        if (strcmp(tokens[COMMAND_TOKEN].value, "cas") == 0 && (comm = NREAD_CAS)) {
        -: 2879:
       17: 2880:            WANT_TOKENS_OR(ntokens, 7, 8);
       16: 2881:            process_update_command(c, tokens, ntokens, comm, true);
        3: 2882:        } else if (strcmp(tokens[COMMAND_TOKEN].value, "cache_memlimit") == 0) {
        -: 2883:
       3*: 2884:            WANT_TOKENS_OR(ntokens, 3, 4);
        3: 2885:            process_memlimit_command(c, tokens, ntokens);
        -: 2886:        } else {
    #####: 2887:            out_string(c, "ERROR");
        -: 2888:        }
        -: 2889:    } else if (first == 'i') {
      263: 2890:        if (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0) {
        -: 2891:
     263*: 2892:            WANT_TOKENS_OR(ntokens, 4, 5);
      263: 2893:            process_arithmetic_command(c, tokens, ntokens, 1);
        -: 2894:        } else {
    #####: 2895:            out_string(c, "ERROR");
        -: 2896:        }
        -: 2897:    } else if (first == 'm'){
    #####: 2898:        if(strcmp(tokens[COMMAND_TOKEN].value, "mult") == 0){
        -: 2899:            /*MULTIPLY*/
    #####: 2900:            WANT_TOKENS_OR(ntokens, 4, 5);
    #####: 2901:            process_mult_command(c, tokens, ntokens, 1);
        -: 2902:        }
        -: 2903:    } else if (first == 'd') {
   141105: 2904:        if (strcmp(tokens[COMMAND_TOKEN].value, "delete") == 0) {
        -: 2905:
  141090*: 2906:            WANT_TOKENS(ntokens, 3, 5);
   141090: 2907:            process_delete_command(c, tokens, ntokens);
       15: 2908:        } else if(strcmp(tokens[COMMAND_TOKEN].value, "div") == 0){
        -: 2909:            /*DIVIDE*/
    #####: 2910:            out_string(c, "Here");
    #####: 2911:            WANT_TOKENS_OR(ntokens, 4, 5);
    #####: 2912:            process_mult_command(c, tokens, ntokens, 0);
       15: 2913:        } else if (strcmp(tokens[COMMAND_TOKEN].value, "decr") == 0) {
        -: 2914:
      10*: 2915:            WANT_TOKENS_OR(ntokens, 4, 5);
       10: 2916:            process_arithmetic_command(c, tokens, ntokens, 0);
        -: 2917:#ifdef MEMCACHED_DEBUG
        5: 2918:        } else if (strcmp(tokens[COMMAND_TOKEN].value, "debugtime") == 0) {
        5: 2919:            WANT_TOKENS_MIN(ntokens, 2);
        5: 2920:            process_debugtime_command(c, tokens, ntokens);
        -: 2921:#endif
        -: 2922:        } else {
    #####: 2923:            out_string(c, "ERROR");
        -: 2924:        }
        -: 2925:    } else if (first == 't') {
     2004: 2926:        if (strcmp(tokens[COMMAND_TOKEN].value, "touch") == 0) {
        -: 2927:
    2004*: 2928:            WANT_TOKENS_OR(ntokens, 4, 5);
     2004: 2929:            process_touch_command(c, tokens, ntokens);
        -: 2930:        } else {
    #####: 2931:            out_string(c, "ERROR");
        -: 2932:        }
     8066: 2933:    } else if (
     8066: 2934:                (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
     8063: 2935:                (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ) {
        -: 2936:
    8006*: 2937:        WANT_TOKENS_OR(ntokens, 6, 7);
     8006: 2938:        process_update_command(c, tokens, ntokens, comm, false);
        -: 2939:
       60: 2940:    } else if (strcmp(tokens[COMMAND_TOKEN].value, "bget") == 0) {
        -: 2941:        // ancient "binary get" command which isn't in any documentation, was
        -: 2942:        // removed > 10 years ago, etc. Keeping for compatibility reasons but
        -: 2943:        // we should look deeper into client code and remove this.
    #####: 2944:        WANT_TOKENS_MIN(ntokens, 3);
    #####: 2945:        process_get_command(c, tokens, ntokens, false, false);
        -: 2946:
       60: 2947:    } else if (strcmp(tokens[COMMAND_TOKEN].value, "flush_all") == 0) {
        -: 2948:
      12*: 2949:        WANT_TOKENS(ntokens, 2, 4);
       12: 2950:        process_flush_all_command(c, tokens, ntokens);
        -: 2951:
       48: 2952:    } else if (strcmp(tokens[COMMAND_TOKEN].value, "version") == 0) {
        -: 2953:
        6: 2954:        process_version_command(c);
        -: 2955:
       42: 2956:    } else if (strcmp(tokens[COMMAND_TOKEN].value, "quit") == 0) {
        -: 2957:
        3: 2958:        process_quit_command(c);
        -: 2959:
       39: 2960:    } else if (strcmp(tokens[COMMAND_TOKEN].value, "lru_crawler") == 0) {
        -: 2961:
        9: 2962:        process_lru_crawler_command(c, tokens, ntokens);
        -: 2963:
       30: 2964:    } else if (strcmp(tokens[COMMAND_TOKEN].value, "watch") == 0) {
        -: 2965:
       11: 2966:        process_watch_command(c, tokens, ntokens);
        -: 2967:
       19: 2968:    } else if (strcmp(tokens[COMMAND_TOKEN].value, "verbosity") == 0) {
       2*: 2969:        WANT_TOKENS_OR(ntokens, 3, 4);
        2: 2970:        process_verbosity_command(c, tokens, ntokens);
       17: 2971:    } else if (strcmp(tokens[COMMAND_TOKEN].value, "lru") == 0) {
    #####: 2972:        WANT_TOKENS_MIN(ntokens, 3);
    #####: 2973:        process_lru_command(c, tokens, ntokens);
        -: 2974:#ifdef MEMCACHED_DEBUG
        -: 2975:    // commands which exist only for testing the memcached's security protection
       17: 2976:    } else if (strcmp(tokens[COMMAND_TOKEN].value, "misbehave") == 0) {
    #####: 2977:        process_misbehave_command(c);
        -: 2978:#endif
        -: 2979:#ifdef EXTSTORE
       17: 2980:    } else if (strcmp(tokens[COMMAND_TOKEN].value, "extstore") == 0) {
      11*: 2981:        WANT_TOKENS_MIN(ntokens, 3);
       11: 2982:        process_extstore_command(c, tokens, ntokens);
        -: 2983:#endif
        -: 2984:#ifdef TLS
        -: 2985:    } else if (strcmp(tokens[COMMAND_TOKEN].value, "refresh_certs") == 0) {
        -: 2986:        process_refresh_certs_command(c, tokens, ntokens);
        -: 2987:#endif
        -: 2988:    } else {
        6: 2989:        if (strncmp(tokens[ntokens - 2].value, "HTTP/", 5) == 0) {
        4: 2990:            conn_set_state(c, conn_closing);
        -: 2991:        } else {
        2: 2992:            out_string(c, "ERROR");
        -: 2993:        }
        -: 2994:    }
        -: 2995:    return;
        -: 2996:}
        -: 2997:
        -: 2998:
